:toc: macro

= TBTC v2

https://github.com/keep-network/tbtc-v2/actions/workflows/contracts.yml[image:https://img.shields.io/github/workflow/status/keep-network/tbtc-v2/Solidity/main?event=push&label=Solidity%20build[Solidity contracts build status]]
https://discord.gg/g2H4Jn4D[image:https://img.shields.io/badge/chat-Discord-blueViolet.svg[Chat
with us on Discord]]


For many Bitcoin holders, one question remains: how can I move my assets across
blockchains to make them more useful while maintaining Bitcoin's core values?

Existing solutions that bridge Bitcoin to Ethereum require users to send their
Bitcoin to an intermediary in exchange for an Ethereum token that represents the
original asset. This centralized model requires you to trust a third party and
is prone to censorship, threatening Bitcoin's promise of secure, permissionless
decentralization.

Threshold aims to solve this problem with TBTC v2.

The second generation of TBTC is a truly decentralized bridge between Bitcoin
and Ethereum. It provides Bitcoin holders permissionless access to DeFi and the
expanding web3 universe.

TBTC v2 replaces centralized intermediaries with a randomly selected group of
node operators on the Threshold Network. This group of independent operators
works together to secure your deposited Bitcoin through threshold cryptography.
That means TBTC v2 requires a majority threshold agreement before operators
perform any action with your Bitcoin. By rotating the selection of operators,
TBTC v2 protects against any malicious individual or group of operators seizing
control. Unlike other solutions on the market, users on TBTC v2 are reliant on
math, not hardware or people. Additionally, TBTC v2 is open and accessible to
anyone.
  
TBTC v2 allows anyone to use Bitcoin in the expanding DeFi and Web3 universe
without a third-party intermediary. 

This repository contains:

- TBTC v2 link:solidity/[Solidity smart contracts],
- TBTC v2 link:typescript/[Typescript library],
- TBTC v2 link:docs/[documentation],
- TBTC v2 Yearn vault link:yearn/[Solidity smart contracts].

toc::[]

== Overview
tBTCv2 uses the
link:https://github.com/keep-network/keep-core/tree/main/solidity/random-beacon[Random
Beacon] and link:https://github.com/keep-network/sortition-pools[Sortition Pool]
to generate governable-sized (starting at 51-of-100)
link:https://eprint.iacr.org/2019/114.pdf[threshold ECDSA]
Bitcoin wallets at a governable frequency (starting weekly). The youngest
wallet accepts new deposits, and the oldest wallet serves redemptions.

Depositing Bitcoin into the tBTCv2 bridge grants a transferable balance, which
can be used to mint a supply-pegged ERC-20: TBTC. For an in-depth explanation
about the design, see link:docs/rfc/rfc-1.adoc[RFC 1: tBTCv2 Design].

== The Mechanism

=== Wallet Lifecycle

==== Wallet Creation

We kick off the wallet creation mechanism in
link:https://github.com/keep-network/keep-core/tree/main/solidity/ecdsa[keep-core/ecdsa]
via `Bridge.requestNewWallet`, which verifies:

* That we're not currently already creating a wallet
* If we have an active wallet it either:
** Is old enough and has over `walletCreationMinBtcBalance` 
** Has over `walletCreationMaxBtcBalance`

If everything looks good, we kick off the wallet creation mechanism outlined in 
link:https://github.com/keep-network/keep-core/tree/main/solidity/ecdsa#the-mechanism[Wallet
Creation] (through keep-core/ecdsa). This leans heavily on the 
link:https://github.com/keep-network/keep-core/tree/main/solidity/random-beacon#the-mechanism[Random
Beacon].

Once that is finished, the wallet registry can call
`Bridge.__ecdsaWalletCreatedCallback`, which sets the new wallet as the active
wallet. Going forward, it will receive deposits.

==== Depositing

When the system has an active wallet (denoted by
`Bridge.activeWalletPubKeyHash()`), it is ready for deposits. A user can pay to
a P2(W)SH address with the following Bitcoin script:

```
<depositor> DROP
<blindingFactor> DROP
DUP HASH160 <walletPubKeyHash> EQUAL
IF
  CHECKSIG
ELSE
  DUP HASH160 <refundPubkeyHash> EQUALVERIFY
  <refundLocktime> CHECKLOCKTIMEVERIFY DROP
  CHECKSIG
ENDIF
```

Since each depositor will have their ethereum address (the `depositor` field),
and a different `blindingFactor` per deposit, each script will be unique and
each script hash will be unique. The `<depositor> DROP <blindingFactor> DROP`
header is a way to make the script commit to a particular eth address owner at
Bitcoin deposit time, and it's what allows us to link the chains. `DUP HASH160
<walletPubKeyHash> EQUALVERIFY CHECKSIG` is a standard P2PKH, so we slightly
modify that to check to see if the signature matches rather than failing. If it
doesn't match, we want to check a _different_ pkh: `refundPubkeyHash`. This is
a user-provided refund address, and it's only available after `refundLocktime`.
The idea is that they can send funds to this script hash, and if the system is
broken or if something goes wrong, then after `refundLocktime` (30 days), they
can send their funds back to `refundPubkeyHash` themselves. This would only
work if the wallet hadn't <sweeping,touched> those funds yet.

Once a Bitcoin user sends such a deposit, because their P2(W)SH address is
unique to them, _only they_ know that they deposited into TBTCv2 until they
reveal that they did so. To the rest of the Bitcoin world, this looks like a
nondescript payment to a meaningless P2SH address. They make this reveal (which
can be done immediately; no need to wait for confirmations) by calling
`Bridge.revealDeposit`.

`Bridge.revealDeposit` takes in the funding transaction, and then the necessary
information to reconstruct the Bitcoin script: `depositor`, `blindingFactor`,
`walletPubKeyHash` and `refundPubkeyHash`. Then, it makes sure that the funding
transaction happened on bitcoin, reconstructs the script, hashes it, verifies
that the hashes match, and then stores the deposit as waiting to be
<sweeping,swept> associated to the provided `depositor`.

[sweeping]
==== Sweeping



==== Wallet Closure

Wallets can close in a few ways:

* The operators notify the chain that the wallet is failing a heartbeat: `Wallets.notifyWalletHeartbeatFailed`
* Someone notifies the chain that the wallet timed out while filling a redemption: `Wallets.notifyWalletTimedOutRedemption`
* Someone notifies the chain that the wallet is too old: `Wallets.notifyCloseableWallet`
* Someone notifies the chain that the wallet has too few BTC remaining: `Wallets.notifyCloseableWallet`

Each of the above routes into `Wallets.moveFunds`. If the wallet has no main
UTXO, then we can start closing it immediately via
`Wallets.beginWalletClosing`. Otherwise, we change it's state to
`WalletState.MovingFunds`, decrease the live wallet count, and give the wallet
a deadline to move its funds to other wallet(s). If this was the active wallet,
then we currently have no active wallet.

After `movingFundsTimeout` goes by, anyone can call
`MovingFunds.notifyMovingFundsTimeout` which pipes into
`Wallets.terminateWallet` followed by `ecdsaWalletRegistry.seize`.
`terminateWallet`, in this case passes through to
`ecdsaWalletRegistry.closeWallet` after changing the state to
`WalletState.Terminated`.

Furthermore, the `ecdsaWalletRegistry.seize` call is punishing the operators by
`movedFundsSweepTimeoutSlashingAmount` and rewarding the notifier with a reward
multiplier of `movedFundsSweepTimeoutNotifierRewardMultiplier` (the notifier
gets a percentaged of the slashed stake).

In order to avoid this, the wallet has to commit to which wallets they'll send
the funds to (`MovingFunds.submitMovingFundsCommitment`), then actually send
the funds to those wallets, and then prove that they did it
(`MovingFunds.submitMovingFundsProof`) before the time runs out.

The commitment involves submitting a list of wallet public keys that:

* Aren't the source wallet 
* Are in ascending order
* Are Live

We store the hash of the list in `movingFundsTargetWalletsCommitmentHash`.
Off-chain we come to consensus by picking the Live wallets whose public key
hashes are the closest to the source wallet's public key hash in terms of clock
distance (modulus distance). This makes public key hashes in the middle of the
range no more likely to be picked than ones near the ends. We pick a number of
wallets equal to `min(liveWalletsCount, ceil(walletBtcBalance /
walletMaxBtcTransfer))`, where `walletMaxBtcTransfer` is governable.

In `submitMovingFundsProof`, we prove that the bitcoin transaction happened and
has an appropriate number of confirmations, and then mark the source wallet's
UTXO as spent via `OutboundTx.processWalletOutboundTxInput`. We pass the
transaction's outputs into `MovingFunds.processMovingFundsTxOutputs`, sum up
the funds and return a hash of the target wallets to check against
`movingFundsTargetWalletsCommitmentHash` in `notifyWalletFundsMoved`.

If the hashes match, we begin closing the wallet via `beginWalletClosing`.
After `walletClosingPeriod` has elapsed, anyone can call
`Bridge.notifyWalletClosingPeriodElapsed` to close the wallet.

== Parameters

[%header,cols="3m,4,^1,^2m"]
|=== 
^|Property Name
^|Description
|Governable
|Default Value

4+s|Wallet Creation

|walletCreationPeriod      
|Length of time a wallet needs to exist for before a new one can be created
|Yes
|`1 week`

|walletCreationMinBtcBalance
|The minimum amount of BTC an active wallet needs to have before we allow for
the creation of a new active wallet.
|Yes
|`5 BTC`

|walletCreationMaxBtcBalance
|The amount of BTC an active wallet needs to have where we allow for the
creation of a new active wallet regardless of age.
|Yes
|`25 BTC`

4+s|Wallet Closure

|movingFundsTimeout
|The amount of time a wallet has to move funds before facing penalty.
|Yes
|`1 week`

|movedFundsSweepTimeoutSlashingAmount
|The amount of stake to slash if the wallet does not move its funds in time.
|Yes
|`100% of min-stake`

|movedFundsSweepTimeoutNotifierRewardMultiplier
|The the percentage of the slashed stake that the notifier receives as a reward.
|Yes
|`5%`

|walletMaxBtcTransfer
|The threshold at which we try to divide up a closing wallet into multiple target wallets
|Yes
|`50 BTC`

|walletClosingPeriod
|The amount of time the wallet remains in the `Closing` state before it is closed.
|Yes
|`3 days`
