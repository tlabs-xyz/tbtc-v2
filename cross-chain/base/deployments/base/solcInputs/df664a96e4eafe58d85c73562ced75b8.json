{
  "language": "Solidity",
  "sources": {
    "@keep-network/bitcoin-spv-sol/contracts/BTCUtils.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/** @title BitcoinSPV */\n/** @author Summa (https://summa.one) */\n\nimport {BytesLib} from \"./BytesLib.sol\";\nimport {SafeMath} from \"./SafeMath.sol\";\n\nlibrary BTCUtils {\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n\n    // The target at minimum Difficulty. Also the target of the genesis block\n    uint256 public constant DIFF1_TARGET = 0xffff0000000000000000000000000000000000000000000000000000;\n\n    uint256 public constant RETARGET_PERIOD = 2 * 7 * 24 * 60 * 60;  // 2 weeks in seconds\n    uint256 public constant RETARGET_PERIOD_BLOCKS = 2016;  // 2 weeks in blocks\n\n    uint256 public constant ERR_BAD_ARG = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /* ***** */\n    /* UTILS */\n    /* ***** */\n\n    /// @notice         Determines the length of a VarInt in bytes\n    /// @dev            A VarInt of >1 byte is prefixed with a flag indicating its length\n    /// @param _flag    The first byte of a VarInt\n    /// @return         The number of non-flag bytes in the VarInt\n    function determineVarIntDataLength(bytes memory _flag) internal pure returns (uint8) {\n        return determineVarIntDataLengthAt(_flag, 0);\n    }\n\n    /// @notice         Determines the length of a VarInt in bytes\n    /// @dev            A VarInt of >1 byte is prefixed with a flag indicating its length\n    /// @param _b       The byte array containing a VarInt\n    /// @param _at      The position of the VarInt in the array\n    /// @return         The number of non-flag bytes in the VarInt\n    function determineVarIntDataLengthAt(bytes memory _b, uint256 _at) internal pure returns (uint8) {\n        if (uint8(_b[_at]) == 0xff) {\n            return 8;  // one-byte flag, 8 bytes data\n        }\n        if (uint8(_b[_at]) == 0xfe) {\n            return 4;  // one-byte flag, 4 bytes data\n        }\n        if (uint8(_b[_at]) == 0xfd) {\n            return 2;  // one-byte flag, 2 bytes data\n        }\n\n        return 0;  // flag is data\n    }\n\n    /// @notice     Parse a VarInt into its data length and the number it represents\n    /// @dev        Useful for Parsing Vins and Vouts. Returns ERR_BAD_ARG if insufficient bytes.\n    ///             Caller SHOULD explicitly handle this case (or bubble it up)\n    /// @param _b   A byte-string starting with a VarInt\n    /// @return     number of bytes in the encoding (not counting the tag), the encoded int\n    function parseVarInt(bytes memory _b) internal pure returns (uint256, uint256) {\n        return parseVarIntAt(_b, 0);\n    }\n\n    /// @notice     Parse a VarInt into its data length and the number it represents\n    /// @dev        Useful for Parsing Vins and Vouts. Returns ERR_BAD_ARG if insufficient bytes.\n    ///             Caller SHOULD explicitly handle this case (or bubble it up)\n    /// @param _b   A byte-string containing a VarInt\n    /// @param _at  The position of the VarInt\n    /// @return     number of bytes in the encoding (not counting the tag), the encoded int\n    function parseVarIntAt(bytes memory _b, uint256 _at) internal pure returns (uint256, uint256) {\n        uint8 _dataLen = determineVarIntDataLengthAt(_b, _at);\n\n        if (_dataLen == 0) {\n            return (0, uint8(_b[_at]));\n        }\n        if (_b.length < 1 + _dataLen + _at) {\n            return (ERR_BAD_ARG, 0);\n        }\n        uint256 _number;\n        if (_dataLen == 2) {\n            _number = reverseUint16(uint16(_b.slice2(1 + _at)));\n        } else if (_dataLen == 4) {\n            _number = reverseUint32(uint32(_b.slice4(1 + _at)));\n        } else if (_dataLen == 8) {\n            _number = reverseUint64(uint64(_b.slice8(1 + _at)));\n        }\n        return (_dataLen, _number);\n    }\n\n    /// @notice          Changes the endianness of a byte array\n    /// @dev             Returns a new, backwards, bytes\n    /// @param _b        The bytes to reverse\n    /// @return          The reversed bytes\n    function reverseEndianness(bytes memory _b) internal pure returns (bytes memory) {\n        bytes memory _newValue = new bytes(_b.length);\n\n        for (uint i = 0; i < _b.length; i++) {\n            _newValue[_b.length - i - 1] = _b[i];\n        }\n\n        return _newValue;\n    }\n\n    /// @notice          Changes the endianness of a uint256\n    /// @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n    /// @param _b        The unsigned integer to reverse\n    /// @return v        The reversed value\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n        // swap 2-byte long pairs\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n        // swap 4-byte long pairs\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n        // swap 8-byte long pairs\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    /// @notice          Changes the endianness of a uint64\n    /// @param _b        The unsigned integer to reverse\n    /// @return v        The reversed value\n    function reverseUint64(uint64 _b) internal pure returns (uint64 v) {\n        v = _b;\n\n        // swap bytes\n        v = ((v >> 8) & 0x00FF00FF00FF00FF) |\n            ((v & 0x00FF00FF00FF00FF) << 8);\n        // swap 2-byte long pairs\n        v = ((v >> 16) & 0x0000FFFF0000FFFF) |\n            ((v & 0x0000FFFF0000FFFF) << 16);\n        // swap 4-byte long pairs\n        v = (v >> 32) | (v << 32);\n    }\n\n    /// @notice          Changes the endianness of a uint32\n    /// @param _b        The unsigned integer to reverse\n    /// @return v        The reversed value\n    function reverseUint32(uint32 _b) internal pure returns (uint32 v) {\n        v = _b;\n\n        // swap bytes\n        v = ((v >> 8) & 0x00FF00FF) |\n            ((v & 0x00FF00FF) << 8);\n        // swap 2-byte long pairs\n        v = (v >> 16) | (v << 16);\n    }\n\n    /// @notice          Changes the endianness of a uint24\n    /// @param _b        The unsigned integer to reverse\n    /// @return v        The reversed value\n    function reverseUint24(uint24 _b) internal pure returns (uint24 v) {\n        v =  (_b << 16) | (_b & 0x00FF00) | (_b >> 16);\n    }\n\n    /// @notice          Changes the endianness of a uint16\n    /// @param _b        The unsigned integer to reverse\n    /// @return v        The reversed value\n    function reverseUint16(uint16 _b) internal pure returns (uint16 v) {\n        v =  (_b << 8) | (_b >> 8);\n    }\n\n\n    /// @notice          Converts big-endian bytes to a uint\n    /// @dev             Traverses the byte array and sums the bytes\n    /// @param _b        The big-endian bytes-encoded integer\n    /// @return          The integer representation\n    function bytesToUint(bytes memory _b) internal pure returns (uint256) {\n        uint256 _number;\n\n        for (uint i = 0; i < _b.length; i++) {\n            _number = _number + uint8(_b[i]) * (2 ** (8 * (_b.length - (i + 1))));\n        }\n\n        return _number;\n    }\n\n    /// @notice          Get the last _num bytes from a byte array\n    /// @param _b        The byte array to slice\n    /// @param _num      The number of bytes to extract from the end\n    /// @return          The last _num bytes of _b\n    function lastBytes(bytes memory _b, uint256 _num) internal pure returns (bytes memory) {\n        uint256 _start = _b.length.sub(_num);\n\n        return _b.slice(_start, _num);\n    }\n\n    /// @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n    /// @dev             abi.encodePacked changes the return to bytes instead of bytes32\n    /// @param _b        The pre-image\n    /// @return          The digest\n    function hash160(bytes memory _b) internal pure returns (bytes memory) {\n        return abi.encodePacked(ripemd160(abi.encodePacked(sha256(_b))));\n    }\n\n    /// @notice          Implements bitcoin's hash160 (sha2 + ripemd160)\n    /// @dev             sha2 precompile at address(2), ripemd160 at address(3)\n    /// @param _b        The pre-image\n    /// @return res      The digest\n    function hash160View(bytes memory _b) internal view returns (bytes20 res) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            pop(staticcall(gas(), 2, add(_b, 32), mload(_b), 0x00, 32))\n            pop(staticcall(gas(), 3, 0x00, 32, 0x00, 32))\n            // read from position 12 = 0c\n            res := mload(0x0c)\n        }\n    }\n\n    /// @notice          Implements bitcoin's hash256 (double sha2)\n    /// @dev             abi.encodePacked changes the return to bytes instead of bytes32\n    /// @param _b        The pre-image\n    /// @return          The digest\n    function hash256(bytes memory _b) internal pure returns (bytes32) {\n        return sha256(abi.encodePacked(sha256(_b)));\n    }\n\n    /// @notice          Implements bitcoin's hash256 (double sha2)\n    /// @dev             sha2 is precompiled smart contract located at address(2)\n    /// @param _b        The pre-image\n    /// @return res      The digest\n    function hash256View(bytes memory _b) internal view returns (bytes32 res) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            pop(staticcall(gas(), 2, add(_b, 32), mload(_b), 0x00, 32))\n            pop(staticcall(gas(), 2, 0x00, 32, 0x00, 32))\n            res := mload(0x00)\n        }\n    }\n\n    /// @notice          Implements bitcoin's hash256 on a pair of bytes32\n    /// @dev             sha2 is precompiled smart contract located at address(2)\n    /// @param _a        The first bytes32 of the pre-image\n    /// @param _b        The second bytes32 of the pre-image\n    /// @return res      The digest\n    function hash256Pair(bytes32 _a, bytes32 _b) internal view returns (bytes32 res) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(0x00, _a)\n            mstore(0x20, _b)\n            pop(staticcall(gas(), 2, 0x00, 64, 0x00, 32))\n            pop(staticcall(gas(), 2, 0x00, 32, 0x00, 32))\n            res := mload(0x00)\n        }\n    }\n\n    /// @notice          Implements bitcoin's hash256 (double sha2)\n    /// @dev             sha2 is precompiled smart contract located at address(2)\n    /// @param _b        The array containing the pre-image\n    /// @param at        The start of the pre-image\n    /// @param len       The length of the pre-image\n    /// @return res      The digest\n    function hash256Slice(\n        bytes memory _b,\n        uint256 at,\n        uint256 len\n    ) internal view returns (bytes32 res) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            pop(staticcall(gas(), 2, add(_b, add(32, at)), len, 0x00, 32))\n            pop(staticcall(gas(), 2, 0x00, 32, 0x00, 32))\n            res := mload(0x00)\n        }\n    }\n\n    /* ************ */\n    /* Legacy Input */\n    /* ************ */\n\n    /// @notice          Extracts the nth input from the vin (0-indexed)\n    /// @dev             Iterates over the vin. If you need to extract several, write a custom function\n    /// @param _vin      The vin as a tightly-packed byte array\n    /// @param _index    The 0-indexed location of the input to extract\n    /// @return          The input as a byte array\n    function extractInputAtIndex(bytes memory _vin, uint256 _index) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _nIns;\n\n        (_varIntDataLen, _nIns) = parseVarInt(_vin);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Read overrun during VarInt parsing\");\n        require(_index < _nIns, \"Vin read overrun\");\n\n        uint256 _len = 0;\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 _i = 0; _i < _index; _i ++) {\n            _len = determineInputLengthAt(_vin, _offset);\n            require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n            _offset = _offset + _len;\n        }\n\n        _len = determineInputLengthAt(_vin, _offset);\n        require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _vin.slice(_offset, _len);\n    }\n\n    /// @notice          Determines whether an input is legacy\n    /// @dev             False if no scriptSig, otherwise True\n    /// @param _input    The input\n    /// @return          True for legacy, False for witness\n    function isLegacyInput(bytes memory _input) internal pure returns (bool) {\n        return _input[36] != hex\"00\";\n    }\n\n    /// @notice          Determines the length of a scriptSig in an input\n    /// @dev             Will return 0 if passed a witness input.\n    /// @param _input    The LEGACY input\n    /// @return          The length of the script sig\n    function extractScriptSigLen(bytes memory _input) internal pure returns (uint256, uint256) {\n        return extractScriptSigLenAt(_input, 0);\n    }\n\n    /// @notice          Determines the length of a scriptSig in an input\n    ///                  starting at the specified position\n    /// @dev             Will return 0 if passed a witness input.\n    /// @param _input    The byte array containing the LEGACY input\n    /// @param _at       The position of the input in the array\n    /// @return          The length of the script sig\n    function extractScriptSigLenAt(bytes memory _input, uint256 _at) internal pure returns (uint256, uint256) {\n        if (_input.length < 37 + _at) {\n            return (ERR_BAD_ARG, 0);\n        }\n\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = parseVarIntAt(_input, _at + 36);\n\n        return (_varIntDataLen, _scriptSigLen);\n    }\n\n    /// @notice          Determines the length of an input from its scriptSig\n    /// @dev             36 for outpoint, 1 for scriptSig length, 4 for sequence\n    /// @param _input    The input\n    /// @return          The length of the input in bytes\n    function determineInputLength(bytes memory _input) internal pure returns (uint256) {\n        return determineInputLengthAt(_input, 0);\n    }\n\n    /// @notice          Determines the length of an input from its scriptSig,\n    ///                  starting at the specified position\n    /// @dev             36 for outpoint, 1 for scriptSig length, 4 for sequence\n    /// @param _input    The byte array containing the input\n    /// @param _at       The position of the input in the array\n    /// @return          The length of the input in bytes\n    function determineInputLengthAt(bytes memory _input, uint256 _at) internal pure returns (uint256) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLenAt(_input, _at);\n        if (_varIntDataLen == ERR_BAD_ARG) {\n            return ERR_BAD_ARG;\n        }\n\n        return 36 + 1 + _varIntDataLen + _scriptSigLen + 4;\n    }\n\n    /// @notice          Extracts the LE sequence bytes from an input\n    /// @dev             Sequence is used for relative time locks\n    /// @param _input    The LEGACY input\n    /// @return          The sequence bytes (LE uint)\n    function extractSequenceLELegacy(bytes memory _input) internal pure returns (bytes4) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _input.slice4(36 + 1 + _varIntDataLen + _scriptSigLen);\n    }\n\n    /// @notice          Extracts the sequence from the input\n    /// @dev             Sequence is a 4-byte little-endian number\n    /// @param _input    The LEGACY input\n    /// @return          The sequence number (big-endian uint)\n    function extractSequenceLegacy(bytes memory _input) internal pure returns (uint32) {\n        uint32 _leSeqence = uint32(extractSequenceLELegacy(_input));\n        uint32 _beSequence = reverseUint32(_leSeqence);\n        return _beSequence;\n    }\n    /// @notice          Extracts the VarInt-prepended scriptSig from the input in a tx\n    /// @dev             Will return hex\"00\" if passed a witness input\n    /// @param _input    The LEGACY input\n    /// @return          The length-prepended scriptSig\n    function extractScriptSig(bytes memory _input) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _input.slice(36, 1 + _varIntDataLen + _scriptSigLen);\n    }\n\n\n    /* ************* */\n    /* Witness Input */\n    /* ************* */\n\n    /// @notice          Extracts the LE sequence bytes from an input\n    /// @dev             Sequence is used for relative time locks\n    /// @param _input    The WITNESS input\n    /// @return          The sequence bytes (LE uint)\n    function extractSequenceLEWitness(bytes memory _input) internal pure returns (bytes4) {\n        return _input.slice4(37);\n    }\n\n    /// @notice          Extracts the sequence from the input in a tx\n    /// @dev             Sequence is a 4-byte little-endian number\n    /// @param _input    The WITNESS input\n    /// @return          The sequence number (big-endian uint)\n    function extractSequenceWitness(bytes memory _input) internal pure returns (uint32) {\n        uint32 _leSeqence = uint32(extractSequenceLEWitness(_input));\n        uint32 _inputeSequence = reverseUint32(_leSeqence);\n        return _inputeSequence;\n    }\n\n    /// @notice          Extracts the outpoint from the input in a tx\n    /// @dev             32-byte tx id with 4-byte index\n    /// @param _input    The input\n    /// @return          The outpoint (LE bytes of prev tx hash + LE bytes of prev tx index)\n    function extractOutpoint(bytes memory _input) internal pure returns (bytes memory) {\n        return _input.slice(0, 36);\n    }\n\n    /// @notice          Extracts the outpoint tx id from an input\n    /// @dev             32-byte tx id\n    /// @param _input    The input\n    /// @return          The tx id (little-endian bytes)\n    function extractInputTxIdLE(bytes memory _input) internal pure returns (bytes32) {\n        return _input.slice32(0);\n    }\n\n    /// @notice          Extracts the outpoint tx id from an input\n    ///                  starting at the specified position\n    /// @dev             32-byte tx id\n    /// @param _input    The byte array containing the input\n    /// @param _at       The position of the input\n    /// @return          The tx id (little-endian bytes)\n    function extractInputTxIdLeAt(bytes memory _input, uint256 _at) internal pure returns (bytes32) {\n        return _input.slice32(_at);\n    }\n\n    /// @notice          Extracts the LE tx input index from the input in a tx\n    /// @dev             4-byte tx index\n    /// @param _input    The input\n    /// @return          The tx index (little-endian bytes)\n    function extractTxIndexLE(bytes memory _input) internal pure returns (bytes4) {\n        return _input.slice4(32);\n    }\n\n    /// @notice          Extracts the LE tx input index from the input in a tx\n    ///                  starting at the specified position\n    /// @dev             4-byte tx index\n    /// @param _input    The byte array containing the input\n    /// @param _at       The position of the input\n    /// @return          The tx index (little-endian bytes)\n    function extractTxIndexLeAt(bytes memory _input, uint256 _at) internal pure returns (bytes4) {\n        return _input.slice4(32 + _at);\n    }\n\n    /* ****** */\n    /* Output */\n    /* ****** */\n\n    /// @notice          Determines the length of an output\n    /// @dev             Works with any properly formatted output\n    /// @param _output   The output\n    /// @return          The length indicated by the prefix, error if invalid length\n    function determineOutputLength(bytes memory _output) internal pure returns (uint256) {\n        return determineOutputLengthAt(_output, 0);\n    }\n\n    /// @notice          Determines the length of an output\n    ///                  starting at the specified position\n    /// @dev             Works with any properly formatted output\n    /// @param _output   The byte array containing the output\n    /// @param _at       The position of the output\n    /// @return          The length indicated by the prefix, error if invalid length\n    function determineOutputLengthAt(bytes memory _output, uint256 _at) internal pure returns (uint256) {\n        if (_output.length < 9 + _at) {\n            return ERR_BAD_ARG;\n        }\n        uint256 _varIntDataLen;\n        uint256 _scriptPubkeyLength;\n        (_varIntDataLen, _scriptPubkeyLength) = parseVarIntAt(_output, 8 + _at);\n\n        if (_varIntDataLen == ERR_BAD_ARG) {\n            return ERR_BAD_ARG;\n        }\n\n        // 8-byte value, 1-byte for tag itself\n        return 8 + 1 + _varIntDataLen + _scriptPubkeyLength;\n    }\n\n    /// @notice          Extracts the output at a given index in the TxOuts vector\n    /// @dev             Iterates over the vout. If you need to extract multiple, write a custom function\n    /// @param _vout     The _vout to extract from\n    /// @param _index    The 0-indexed location of the output to extract\n    /// @return          The specified output\n    function extractOutputAtIndex(bytes memory _vout, uint256 _index) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _nOuts;\n\n        (_varIntDataLen, _nOuts) = parseVarInt(_vout);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Read overrun during VarInt parsing\");\n        require(_index < _nOuts, \"Vout read overrun\");\n\n        uint256 _len = 0;\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 _i = 0; _i < _index; _i ++) {\n            _len = determineOutputLengthAt(_vout, _offset);\n            require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptPubkey\");\n            _offset += _len;\n        }\n\n        _len = determineOutputLengthAt(_vout, _offset);\n        require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptPubkey\");\n        return _vout.slice(_offset, _len);\n    }\n\n    /// @notice          Extracts the value bytes from the output in a tx\n    /// @dev             Value is an 8-byte little-endian number\n    /// @param _output   The output\n    /// @return          The output value as LE bytes\n    function extractValueLE(bytes memory _output) internal pure returns (bytes8) {\n        return _output.slice8(0);\n    }\n\n    /// @notice          Extracts the value from the output in a tx\n    /// @dev             Value is an 8-byte little-endian number\n    /// @param _output   The output\n    /// @return          The output value\n    function extractValue(bytes memory _output) internal pure returns (uint64) {\n        uint64 _leValue = uint64(extractValueLE(_output));\n        uint64 _beValue = reverseUint64(_leValue);\n        return _beValue;\n    }\n\n    /// @notice          Extracts the value from the output in a tx\n    /// @dev             Value is an 8-byte little-endian number\n    /// @param _output   The byte array containing the output\n    /// @param _at       The starting index of the output in the array\n    /// @return          The output value\n    function extractValueAt(bytes memory _output, uint256 _at) internal pure returns (uint64) {\n        uint64 _leValue = uint64(_output.slice8(_at));\n        uint64 _beValue = reverseUint64(_leValue);\n        return _beValue;\n    }\n\n    /// @notice          Extracts the data from an op return output\n    /// @dev             Returns hex\"\" if no data or not an op return\n    /// @param _output   The output\n    /// @return          Any data contained in the opreturn output, null if not an op return\n    function extractOpReturnData(bytes memory _output) internal pure returns (bytes memory) {\n        if (_output[9] != hex\"6a\") {\n            return hex\"\";\n        }\n        bytes1 _dataLen = _output[10];\n        return _output.slice(11, uint256(uint8(_dataLen)));\n    }\n\n    /// @notice          Extracts the hash from the output script\n    /// @dev             Determines type by the length prefix and validates format\n    /// @param _output   The output\n    /// @return          The hash committed to by the pk_script, or null for errors\n    function extractHash(bytes memory _output) internal pure returns (bytes memory) {\n        return extractHashAt(_output, 8, _output.length - 8);\n    }\n\n    /// @notice          Extracts the hash from the output script\n    /// @dev             Determines type by the length prefix and validates format\n    /// @param _output   The byte array containing the output\n    /// @param _at       The starting index of the output script in the array\n    ///                  (output start + 8)\n    /// @param _len      The length of the output script\n    ///                  (output length - 8)\n    /// @return          The hash committed to by the pk_script, or null for errors\n    function extractHashAt(\n        bytes memory _output,\n        uint256 _at,\n        uint256 _len\n    ) internal pure returns (bytes memory) {\n        uint8 _scriptLen = uint8(_output[_at]);\n\n        // don't have to worry about overflow here.\n        // if _scriptLen + 1 overflows, then output length would have to be < 1\n        // for this check to pass. if it's < 1, then we errored when assigning\n        // _scriptLen\n        if (_scriptLen + 1 != _len) {\n            return hex\"\";\n        }\n\n        if (uint8(_output[_at + 1]) == 0) {\n            if (_scriptLen < 2) {\n                return hex\"\";\n            }\n            uint256 _payloadLen = uint8(_output[_at + 2]);\n            // Check for maliciously formatted witness outputs.\n            // No need to worry about underflow as long b/c of the `< 2` check\n            if (_payloadLen != _scriptLen - 2 || (_payloadLen != 0x20 && _payloadLen != 0x14)) {\n                return hex\"\";\n            }\n            return _output.slice(_at + 3, _payloadLen);\n        } else {\n            bytes3 _tag = _output.slice3(_at);\n            // p2pkh\n            if (_tag == hex\"1976a9\") {\n                // Check for maliciously formatted p2pkh\n                // No need to worry about underflow, b/c of _scriptLen check\n                if (uint8(_output[_at + 3]) != 0x14 ||\n                    _output.slice2(_at + _len - 2) != hex\"88ac\") {\n                    return hex\"\";\n                }\n                return _output.slice(_at + 4, 20);\n            //p2sh\n            } else if (_tag == hex\"17a914\") {\n                // Check for maliciously formatted p2sh\n                // No need to worry about underflow, b/c of _scriptLen check\n                if (uint8(_output[_at + _len - 1]) != 0x87) {\n                    return hex\"\";\n                }\n                return _output.slice(_at + 3, 20);\n            }\n        }\n        return hex\"\";  /* NB: will trigger on OPRETURN and any non-standard that doesn't overrun */\n    }\n\n    /* ********** */\n    /* Witness TX */\n    /* ********** */\n\n\n    /// @notice      Checks that the vin passed up is properly formatted\n    /// @dev         Consider a vin with a valid vout in its scriptsig\n    /// @param _vin  Raw bytes length-prefixed input vector\n    /// @return      True if it represents a validly formatted vin\n    function validateVin(bytes memory _vin) internal pure returns (bool) {\n        uint256 _varIntDataLen;\n        uint256 _nIns;\n\n        (_varIntDataLen, _nIns) = parseVarInt(_vin);\n\n        // Not valid if it says there are too many or no inputs\n        if (_nIns == 0 || _varIntDataLen == ERR_BAD_ARG) {\n            return false;\n        }\n\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 i = 0; i < _nIns; i++) {\n            // If we're at the end, but still expect more\n            if (_offset >= _vin.length) {\n                return false;\n            }\n\n            // Grab the next input and determine its length.\n            uint256 _nextLen = determineInputLengthAt(_vin, _offset);\n            if (_nextLen == ERR_BAD_ARG) {\n                return false;\n            }\n\n            // Increase the offset by that much\n            _offset += _nextLen;\n        }\n\n        // Returns false if we're not exactly at the end\n        return _offset == _vin.length;\n    }\n\n    /// @notice      Checks that the vout passed up is properly formatted\n    /// @dev         Consider a vout with a valid scriptpubkey\n    /// @param _vout Raw bytes length-prefixed output vector\n    /// @return      True if it represents a validly formatted vout\n    function validateVout(bytes memory _vout) internal pure returns (bool) {\n        uint256 _varIntDataLen;\n        uint256 _nOuts;\n\n        (_varIntDataLen, _nOuts) = parseVarInt(_vout);\n\n        // Not valid if it says there are too many or no outputs\n        if (_nOuts == 0 || _varIntDataLen == ERR_BAD_ARG) {\n            return false;\n        }\n\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 i = 0; i < _nOuts; i++) {\n            // If we're at the end, but still expect more\n            if (_offset >= _vout.length) {\n                return false;\n            }\n\n            // Grab the next output and determine its length.\n            // Increase the offset by that much\n            uint256 _nextLen = determineOutputLengthAt(_vout, _offset);\n            if (_nextLen == ERR_BAD_ARG) {\n                return false;\n            }\n\n            _offset += _nextLen;\n        }\n\n        // Returns false if we're not exactly at the end\n        return _offset == _vout.length;\n    }\n\n\n\n    /* ************ */\n    /* Block Header */\n    /* ************ */\n\n    /// @notice          Extracts the transaction merkle root from a block header\n    /// @dev             Use verifyHash256Merkle to verify proofs with this root\n    /// @param _header   The header\n    /// @return          The merkle root (little-endian)\n    function extractMerkleRootLE(bytes memory _header) internal pure returns (bytes32) {\n        return _header.slice32(36);\n    }\n\n    /// @notice          Extracts the target from a block header\n    /// @dev             Target is a 256-bit number encoded as a 3-byte mantissa and 1-byte exponent\n    /// @param _header   The header\n    /// @return          The target threshold\n    function extractTarget(bytes memory _header) internal pure returns (uint256) {\n        return extractTargetAt(_header, 0);\n    }\n\n    /// @notice          Extracts the target from a block header\n    /// @dev             Target is a 256-bit number encoded as a 3-byte mantissa and 1-byte exponent\n    /// @param _header   The array containing the header\n    /// @param at        The start of the header\n    /// @return          The target threshold\n    function extractTargetAt(bytes memory _header, uint256 at) internal pure returns (uint256) {\n        uint24 _m = uint24(_header.slice3(72 + at));\n        uint8 _e = uint8(_header[75 + at]);\n        uint256 _mantissa = uint256(reverseUint24(_m));\n        uint _exponent = _e - 3;\n\n        return _mantissa * (256 ** _exponent);\n    }\n\n    /// @notice          Calculate difficulty from the difficulty 1 target and current target\n    /// @dev             Difficulty 1 is 0x1d00ffff on mainnet and testnet\n    /// @dev             Difficulty 1 is a 256-bit number encoded as a 3-byte mantissa and 1-byte exponent\n    /// @param _target   The current target\n    /// @return          The block difficulty (bdiff)\n    function calculateDifficulty(uint256 _target) internal pure returns (uint256) {\n        // Difficulty 1 calculated from 0x1d00ffff\n        return DIFF1_TARGET.div(_target);\n    }\n\n    /// @notice          Extracts the previous block's hash from a block header\n    /// @dev             Block headers do NOT include block number :(\n    /// @param _header   The header\n    /// @return          The previous block's hash (little-endian)\n    function extractPrevBlockLE(bytes memory _header) internal pure returns (bytes32) {\n        return _header.slice32(4);\n    }\n\n    /// @notice          Extracts the previous block's hash from a block header\n    /// @dev             Block headers do NOT include block number :(\n    /// @param _header   The array containing the header\n    /// @param at        The start of the header\n    /// @return          The previous block's hash (little-endian)\n    function extractPrevBlockLEAt(\n        bytes memory _header,\n        uint256 at\n    ) internal pure returns (bytes32) {\n        return _header.slice32(4 + at);\n    }\n\n    /// @notice          Extracts the timestamp from a block header\n    /// @dev             Time is not 100% reliable\n    /// @param _header   The header\n    /// @return          The timestamp (little-endian bytes)\n    function extractTimestampLE(bytes memory _header) internal pure returns (bytes4) {\n        return _header.slice4(68);\n    }\n\n    /// @notice          Extracts the timestamp from a block header\n    /// @dev             Time is not 100% reliable\n    /// @param _header   The header\n    /// @return          The timestamp (uint)\n    function extractTimestamp(bytes memory _header) internal pure returns (uint32) {\n        return reverseUint32(uint32(extractTimestampLE(_header)));\n    }\n\n    /// @notice          Extracts the expected difficulty from a block header\n    /// @dev             Does NOT verify the work\n    /// @param _header   The header\n    /// @return          The difficulty as an integer\n    function extractDifficulty(bytes memory _header) internal pure returns (uint256) {\n        return calculateDifficulty(extractTarget(_header));\n    }\n\n    /// @notice          Concatenates and hashes two inputs for merkle proving\n    /// @param _a        The first hash\n    /// @param _b        The second hash\n    /// @return          The double-sha256 of the concatenated hashes\n    function _hash256MerkleStep(bytes memory _a, bytes memory _b) internal view returns (bytes32) {\n        return hash256View(abi.encodePacked(_a, _b));\n    }\n\n    /// @notice          Concatenates and hashes two inputs for merkle proving\n    /// @param _a        The first hash\n    /// @param _b        The second hash\n    /// @return          The double-sha256 of the concatenated hashes\n    function _hash256MerkleStep(bytes32 _a, bytes32 _b) internal view returns (bytes32) {\n        return hash256Pair(_a, _b);\n    }\n\n\n    /// @notice          Verifies a Bitcoin-style merkle tree\n    /// @dev             Leaves are 0-indexed. Inefficient version.\n    /// @param _proof    The proof. Tightly packed LE sha256 hashes. The last hash is the root\n    /// @param _index    The index of the leaf\n    /// @return          true if the proof is valid, else false\n    function verifyHash256Merkle(bytes memory _proof, uint _index) internal view returns (bool) {\n        // Not an even number of hashes\n        if (_proof.length % 32 != 0) {\n            return false;\n        }\n\n        // Special case for coinbase-only blocks\n        if (_proof.length == 32) {\n            return true;\n        }\n\n        // Should never occur\n        if (_proof.length == 64) {\n            return false;\n        }\n\n        bytes32 _root = _proof.slice32(_proof.length - 32);\n        bytes32 _current = _proof.slice32(0);\n        bytes memory _tree = _proof.slice(32, _proof.length - 64);\n\n        return verifyHash256Merkle(_current, _tree, _root, _index);\n    }\n\n    /// @notice          Verifies a Bitcoin-style merkle tree\n    /// @dev             Leaves are 0-indexed. Efficient version.\n    /// @param _leaf     The leaf of the proof. LE sha256 hash.\n    /// @param _tree     The intermediate nodes in the proof.\n    ///                  Tightly packed LE sha256 hashes.\n    /// @param _root     The root of the proof. LE sha256 hash.\n    /// @param _index    The index of the leaf\n    /// @return          true if the proof is valid, else false\n    function verifyHash256Merkle(\n        bytes32 _leaf,\n        bytes memory _tree,\n        bytes32 _root,\n        uint _index\n    ) internal view returns (bool) {\n        // Not an even number of hashes\n        if (_tree.length % 32 != 0) {\n            return false;\n        }\n\n        // Should never occur\n        if (_tree.length == 0) {\n            return false;\n        }\n\n        uint _idx = _index;\n        bytes32 _current = _leaf;\n\n        // i moves in increments of 32\n        for (uint i = 0; i < _tree.length; i += 32) {\n            if (_idx % 2 == 1) {\n                _current = _hash256MerkleStep(_tree.slice32(i), _current);\n            } else {\n                _current = _hash256MerkleStep(_current, _tree.slice32(i));\n            }\n            _idx = _idx >> 1;\n        }\n        return _current == _root;\n    }\n\n    /*\n    NB: https://github.com/bitcoin/bitcoin/blob/78dae8caccd82cfbfd76557f1fb7d7557c7b5edb/src/pow.cpp#L49-L72\n    NB: We get a full-bitlength target from this. For comparison with\n        header-encoded targets we need to mask it with the header target\n        e.g. (full & truncated) == truncated\n    */\n    /// @notice                 performs the bitcoin difficulty retarget\n    /// @dev                    implements the Bitcoin algorithm precisely\n    /// @param _previousTarget  the target of the previous period\n    /// @param _firstTimestamp  the timestamp of the first block in the difficulty period\n    /// @param _secondTimestamp the timestamp of the last block in the difficulty period\n    /// @return                 the new period's target threshold\n    function retargetAlgorithm(\n        uint256 _previousTarget,\n        uint256 _firstTimestamp,\n        uint256 _secondTimestamp\n    ) internal pure returns (uint256) {\n        uint256 _elapsedTime = _secondTimestamp.sub(_firstTimestamp);\n\n        // Normalize ratio to factor of 4 if very long or very short\n        if (_elapsedTime < RETARGET_PERIOD.div(4)) {\n            _elapsedTime = RETARGET_PERIOD.div(4);\n        }\n        if (_elapsedTime > RETARGET_PERIOD.mul(4)) {\n            _elapsedTime = RETARGET_PERIOD.mul(4);\n        }\n\n        /*\n          NB: high targets e.g. ffff0020 can cause overflows here\n              so we divide it by 256**2, then multiply by 256**2 later\n              we know the target is evenly divisible by 256**2, so this isn't an issue\n        */\n\n        uint256 _adjusted = _previousTarget.div(65536).mul(_elapsedTime);\n        return _adjusted.div(RETARGET_PERIOD).mul(65536);\n    }\n}\n"
    },
    "@keep-network/bitcoin-spv-sol/contracts/BytesLib.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/*\n\nhttps://github.com/GNSPS/solidity-bytes-utils/\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <https://unlicense.org>\n*/\n\n\n/** @title BytesLib **/\n/** @author https://github.com/GNSPS **/\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n                add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                        ),\n                        // and now shift left the number of bytes to\n                        // leave space for the length in the slot\n                        exp(0x100, sub(32, newlength))\n                        ),\n                        // increase length by the double of the memory\n                        // bytes length\n                        mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                    ),\n                    and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint _start, uint _length) internal  pure returns (bytes memory res) {\n        if (_length == 0) {\n            return hex\"\";\n        }\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            // Alloc bytes array with additional 32 bytes afterspace and assign it's size\n            res := mload(0x40)\n            mstore(0x40, add(add(res, 64), _length))\n            mstore(res, _length)\n\n            // Compute distance between source and destination pointers\n            let diff := sub(res, add(_bytes, _start))\n\n            for {\n                let src := add(add(_bytes, 32), _start)\n                let end := add(src, _length)\n            } lt(src, end) {\n                src := add(src, 32)\n            } {\n                mstore(add(src, diff), mload(src))\n            }\n        }\n    }\n\n    /// @notice Take a slice of the byte array, overwriting the destination.\n    /// The length of the slice will equal the length of the destination array.\n    /// @dev Make sure the destination array has afterspace if required.\n    /// @param _bytes The source array\n    /// @param _dest The destination array.\n    /// @param _start The location to start in the source array.\n    function sliceInPlace(\n        bytes memory _bytes,\n        bytes memory _dest,\n        uint _start\n    ) internal pure {\n        uint _length = _dest.length;\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            for {\n                let src := add(add(_bytes, 32), _start)\n                let res := add(_dest, 32)\n                let end := add(src, _length)\n            } lt(src, end) {\n                src := add(src, 32)\n                res := add(res, 32)\n            } {\n                mstore(res, mload(src))\n            }\n        }\n    }\n\n    // Static slice functions, no bounds checking\n    /// @notice take a 32-byte slice from the specified position\n    function slice32(bytes memory _bytes, uint _start) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(_bytes, 32), _start))\n        }\n    }\n\n    /// @notice take a 20-byte slice from the specified position\n    function slice20(bytes memory _bytes, uint _start) internal pure returns (bytes20) {\n        return bytes20(slice32(_bytes, _start));\n    }\n\n    /// @notice take a 8-byte slice from the specified position\n    function slice8(bytes memory _bytes, uint _start) internal pure returns (bytes8) {\n        return bytes8(slice32(_bytes, _start));\n    }\n\n    /// @notice take a 4-byte slice from the specified position\n    function slice4(bytes memory _bytes, uint _start) internal pure returns (bytes4) {\n        return bytes4(slice32(_bytes, _start));\n    }\n\n    /// @notice take a 3-byte slice from the specified position\n    function slice3(bytes memory _bytes, uint _start) internal pure returns (bytes3) {\n        return bytes3(slice32(_bytes, _start));\n    }\n\n    /// @notice take a 2-byte slice from the specified position\n    function slice2(bytes memory _bytes, uint _start) internal pure returns (bytes2) {\n        return bytes2(slice32(_bytes, _start));\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        uint _totalLen = _start + 20;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Address conversion out of bounds.\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        uint _totalLen = _start + 32;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Uint conversion out of bounds.\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function toBytes32(bytes memory _source) pure internal returns (bytes32 result) {\n        if (_source.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(_source, 32))\n        }\n    }\n\n    function keccak256Slice(bytes memory _bytes, uint _start, uint _length) pure internal returns (bytes32 result) {\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            result := keccak256(add(add(_bytes, 32), _start), _length)\n        }\n    }\n}\n"
    },
    "@keep-network/bitcoin-spv-sol/contracts/SafeMath.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        c = _a * _b;\n        require(c / _a == _b, \"Overflow during multiplication.\");\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // assert(_b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, \"Underflow during subtraction.\");\n        return _a - _b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        c = _a + _b;\n        require(c >= _a, \"Overflow during addition.\");\n        return c;\n    }\n}\n"
    },
    "@keep-network/random-beacon/contracts/Reimbursable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"./ReimbursementPool.sol\";\n\nabstract contract Reimbursable {\n    // The variable should be initialized by the implementing contract.\n    // slither-disable-next-line uninitialized-state\n    ReimbursementPool public reimbursementPool;\n\n    // Reserved storage space in case we need to add more variables,\n    // since there are upgradeable contracts that inherit from this one.\n    // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    // slither-disable-next-line unused-state\n    uint256[49] private __gap;\n\n    event ReimbursementPoolUpdated(address newReimbursementPool);\n\n    modifier refundable(address receiver) {\n        uint256 gasStart = gasleft();\n        _;\n        reimbursementPool.refund(gasStart - gasleft(), receiver);\n    }\n\n    modifier onlyReimbursableAdmin() virtual {\n        _;\n    }\n\n    function updateReimbursementPool(ReimbursementPool _reimbursementPool)\n        external\n        onlyReimbursableAdmin\n    {\n        emit ReimbursementPoolUpdated(address(_reimbursementPool));\n\n        reimbursementPool = _reimbursementPool;\n    }\n}\n"
    },
    "@keep-network/random-beacon/contracts/ReimbursementPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract ReimbursementPool is Ownable, ReentrancyGuard {\n    /// @notice Authorized contracts that can interact with the reimbursment pool.\n    ///         Authorization can be granted and removed by the owner.\n    mapping(address => bool) public isAuthorized;\n\n    /// @notice Static gas includes:\n    ///         - cost of the refund function\n    ///         - base transaction cost\n    uint256 public staticGas;\n\n    /// @notice Max gas price used to reimburse a transaction submitter. Protects\n    ///         against malicious operator-miners.\n    uint256 public maxGasPrice;\n\n    event StaticGasUpdated(uint256 newStaticGas);\n\n    event MaxGasPriceUpdated(uint256 newMaxGasPrice);\n\n    event SendingEtherFailed(uint256 refundAmount, address receiver);\n\n    event AuthorizedContract(address thirdPartyContract);\n\n    event UnauthorizedContract(address thirdPartyContract);\n\n    event FundsWithdrawn(uint256 withdrawnAmount, address receiver);\n\n    constructor(uint256 _staticGas, uint256 _maxGasPrice) {\n        staticGas = _staticGas;\n        maxGasPrice = _maxGasPrice;\n    }\n\n    /// @notice Receive ETH\n    receive() external payable {}\n\n    /// @notice Refunds ETH to a spender for executing specific transactions.\n    /// @dev Ignoring the result of sending ETH to a receiver is made on purpose.\n    ///      For EOA receiving ETH should always work. If a receiver is a smart\n    ///      contract, then we do not want to fail a transaction, because in some\n    ///      cases the refund is done at the very end of multiple calls where all\n    ///      the previous calls were already paid off. It is a receiver's smart\n    ///      contract resposibility to make sure it can receive ETH.\n    /// @dev Only authorized contracts are allowed calling this function.\n    /// @param gasSpent Gas spent on a transaction that needs to be reimbursed.\n    /// @param receiver Address where the reimbursment is sent.\n    function refund(uint256 gasSpent, address receiver) external nonReentrant {\n        require(\n            isAuthorized[msg.sender],\n            \"Contract is not authorized for a refund\"\n        );\n        require(receiver != address(0), \"Receiver's address cannot be zero\");\n\n        uint256 gasPrice = tx.gasprice < maxGasPrice\n            ? tx.gasprice\n            : maxGasPrice;\n\n        uint256 refundAmount = (gasSpent + staticGas) * gasPrice;\n\n        /* solhint-disable avoid-low-level-calls */\n        // slither-disable-next-line low-level-calls,unchecked-lowlevel\n        (bool sent, ) = receiver.call{value: refundAmount}(\"\");\n        /* solhint-enable avoid-low-level-calls */\n        if (!sent) {\n            // slither-disable-next-line reentrancy-events\n            emit SendingEtherFailed(refundAmount, receiver);\n        }\n    }\n\n    /// @notice Authorize a contract that can interact with this reimbursment pool.\n    ///         Can be authorized by the owner only.\n    /// @param _contract Authorized contract.\n    function authorize(address _contract) external onlyOwner {\n        isAuthorized[_contract] = true;\n\n        emit AuthorizedContract(_contract);\n    }\n\n    /// @notice Unauthorize a contract that was previously authorized to interact\n    ///         with this reimbursment pool. Can be unauthorized by the\n    ///         owner only.\n    /// @param _contract Authorized contract.\n    function unauthorize(address _contract) external onlyOwner {\n        delete isAuthorized[_contract];\n\n        emit UnauthorizedContract(_contract);\n    }\n\n    /// @notice Setting a static gas cost for executing a transaction. Can be set\n    ///         by the owner only.\n    /// @param _staticGas Static gas cost.\n    function setStaticGas(uint256 _staticGas) external onlyOwner {\n        staticGas = _staticGas;\n\n        emit StaticGasUpdated(_staticGas);\n    }\n\n    /// @notice Setting a max gas price for transactions. Can be set by the\n    ///         owner only.\n    /// @param _maxGasPrice Max gas price used to reimburse tx submitters.\n    function setMaxGasPrice(uint256 _maxGasPrice) external onlyOwner {\n        maxGasPrice = _maxGasPrice;\n\n        emit MaxGasPriceUpdated(_maxGasPrice);\n    }\n\n    /// @notice Withdraws all ETH from this pool which are sent to a given\n    ///         address. Can be set by the owner only.\n    /// @param receiver An address where ETH is sent.\n    function withdrawAll(address receiver) external onlyOwner {\n        withdraw(address(this).balance, receiver);\n    }\n\n    /// @notice Withdraws ETH amount from this pool which are sent to a given\n    ///         address. Can be set by the owner only.\n    /// @param amount Amount to withdraw from the pool.\n    /// @param receiver An address where ETH is sent.\n    function withdraw(uint256 amount, address receiver) public onlyOwner {\n        require(\n            address(this).balance >= amount,\n            \"Insufficient contract balance\"\n        );\n        require(receiver != address(0), \"Receiver's address cannot be zero\");\n\n        emit FundsWithdrawn(amount, receiver);\n\n        /* solhint-disable avoid-low-level-calls */\n        // slither-disable-next-line low-level-calls,arbitrary-send\n        (bool sent, ) = receiver.call{value: amount}(\"\");\n        /* solhint-enable avoid-low-level-calls */\n        require(sent, \"Failed to send Ether\");\n    }\n}\n"
    },
    "@keep-network/tbtc-v2/contracts/integrator/AbstractTBTCDepositor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.0;\n\nimport {BTCUtils} from \"@keep-network/bitcoin-spv-sol/contracts/BTCUtils.sol\";\n\nimport \"./IBridge.sol\";\nimport \"./ITBTCVault.sol\";\n\n/// @title Abstract AbstractTBTCDepositor contract.\n/// @notice This abstract contract is meant to facilitate integration of protocols\n///         aiming to use tBTC as an underlying Bitcoin bridge.\n///\n///         Such an integrator is supposed to:\n///         - Create a child contract inheriting from this abstract contract\n///         - Call the `__AbstractTBTCDepositor_initialize` initializer function\n///         - Use the `_initializeDeposit` and `_finalizeDeposit` as part of their\n///           business logic in order to initialize and finalize deposits.\n///\n/// @dev Example usage:\n///      ```\n///      // Example upgradeable integrator contract.\n///      contract ExampleTBTCIntegrator is AbstractTBTCDepositor, Initializable {\n///          /// @custom:oz-upgrades-unsafe-allow constructor\n///          constructor() {\n///              // Prevents the contract from being initialized again.\n///              _disableInitializers();\n///          }\n///\n///          function initialize(\n///              address _bridge,\n///              address _tbtcVault\n///          ) external initializer {\n///              __AbstractTBTCDepositor_initialize(_bridge, _tbtcVault);\n///          }\n///\n///          function startProcess(\n///              IBridgeTypes.BitcoinTxInfo calldata fundingTx,\n///              IBridgeTypes.DepositRevealInfo calldata reveal\n///          ) external {\n///              // Embed necessary context as extra data.\n///              bytes32 extraData = ...;\n///\n///              (uint256 depositKey, uint256 initialDepositAmount) = _initializeDeposit(\n///                  fundingTx,\n///                  reveal,\n///                  extraData\n///              );\n///\n///              // Use the depositKey to track the process.\n///          }\n///\n///          function finalizeProcess(uint256 depositKey) external {\n///              // Ensure the function cannot be called for the same deposit\n///              // twice.\n///\n///              (\n///                  uint256 initialDepositAmount,\n///                  uint256 tbtcAmount,\n///                  bytes32 extraData\n///              ) = _finalizeDeposit(depositKey);\n///\n///              // Do something with the minted TBTC using context\n///              // embedded in the extraData.\n///          }\n///      }\nabstract contract AbstractTBTCDepositor {\n    using BTCUtils for bytes;\n\n    /// @notice Multiplier to convert satoshi to TBTC token units.\n    uint256 public constant SATOSHI_MULTIPLIER = 10**10;\n\n    /// @notice Bridge contract address.\n    IBridge public bridge;\n    /// @notice TBTCVault contract address.\n    ITBTCVault public tbtcVault;\n\n    // Reserved storage space that allows adding more variables without affecting\n    // the storage layout of the child contracts. The convention from OpenZeppelin\n    // suggests the storage space should add up to 50 slots. If more variables are\n    // added in the upcoming versions one need to reduce the array size accordingly.\n    // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    // slither-disable-next-line unused-state\n    uint256[47] private __gap;\n\n    /// @notice Initializes the contract. MUST BE CALLED from the child\n    ///         contract initializer.\n    // slither-disable-next-line dead-code\n    function __AbstractTBTCDepositor_initialize(\n        address _bridge,\n        address _tbtcVault\n    ) internal {\n        require(\n            address(bridge) == address(0) && address(tbtcVault) == address(0),\n            \"AbstractTBTCDepositor already initialized\"\n        );\n\n        require(_bridge != address(0), \"Bridge address cannot be zero\");\n        require(_tbtcVault != address(0), \"TBTCVault address cannot be zero\");\n\n        bridge = IBridge(_bridge);\n        tbtcVault = ITBTCVault(_tbtcVault);\n    }\n\n    /// @notice Initializes a deposit by revealing it to the Bridge.\n    /// @param fundingTx Bitcoin funding transaction data, see `IBridgeTypes.BitcoinTxInfo`.\n    /// @param reveal Deposit reveal data, see `IBridgeTypes.DepositRevealInfo` struct.\n    /// @param extraData 32-byte deposit extra data.\n    /// @return depositKey Deposit key computed as\n    ///         `keccak256(fundingTxHash | reveal.fundingOutputIndex)`. This\n    ///         key can be used to refer to the deposit in the Bridge and\n    ///         TBTCVault contracts.\n    /// @return initialDepositAmount Amount of funding transaction deposit. In\n    ///         TBTC token decimals precision.\n    /// @dev Requirements:\n    ///      - The revealed vault address must match the TBTCVault address,\n    ///      - All requirements from {Bridge#revealDepositWithExtraData}\n    ///        function must be met.\n    /// @dev This function doesn't validate if a deposit has been initialized before,\n    ///      as the Bridge won't allow the same deposit to be revealed twice.\n    // slither-disable-next-line dead-code\n    function _initializeDeposit(\n        IBridgeTypes.BitcoinTxInfo memory fundingTx,\n        IBridgeTypes.DepositRevealInfo memory reveal,\n        bytes32 extraData\n    ) internal returns (uint256 depositKey, uint256 initialDepositAmount) {\n        require(reveal.vault == address(tbtcVault), \"Vault address mismatch\");\n\n        depositKey = _calculateDepositKey(\n            _calculateBitcoinTxHash(fundingTx),\n            reveal.fundingOutputIndex\n        );\n\n        // The Bridge does not allow to reveal the same deposit twice and\n        // revealed deposits stay there forever. The transaction will revert\n        // if the deposit has already been revealed so, there is no need to do\n        // an explicit check here.\n        bridge.revealDepositWithExtraData(fundingTx, reveal, extraData);\n\n        initialDepositAmount =\n            bridge.deposits(depositKey).amount *\n            SATOSHI_MULTIPLIER;\n    }\n\n    /// @notice Finalizes a deposit by calculating the amount of TBTC minted\n    ///         for the deposit.\n    /// @param depositKey Deposit key identifying the deposit.\n    /// @return initialDepositAmount Amount of funding transaction deposit. In\n    ///         TBTC token decimals precision.\n    /// @return tbtcAmount Approximate amount of TBTC minted for the deposit. In\n    ///         TBTC token decimals precision.\n    /// @return extraData 32-byte deposit extra data.\n    /// @dev Requirements:\n    ///      - The deposit must be initialized but not finalized\n    ///        (in the context of this contract) yet.\n    ///      - The deposit must be finalized on the Bridge side. That means the\n    ///        deposit must be either swept or optimistically minted.\n    /// @dev THIS FUNCTION DOESN'T VALIDATE IF A DEPOSIT HAS BEEN FINALIZED BEFORE,\n    ///      IT IS A RESPONSIBILITY OF THE IMPLEMENTING CONTRACT TO ENSURE THIS\n    ///      FUNCTION WON'T BE CALLED TWICE FOR THE SAME DEPOSIT.\n    /// @dev IMPORTANT NOTE: The tbtcAmount returned by this function is an\n    ///      approximation. See documentation of the `calculateTbtcAmount`\n    ///      responsible for calculating this value for more details.\n    // slither-disable-next-line dead-code\n    function _finalizeDeposit(uint256 depositKey)\n        internal\n        returns (\n            uint256 initialDepositAmount,\n            uint256 tbtcAmount,\n            bytes32 extraData\n        )\n    {\n        IBridgeTypes.DepositRequest memory deposit = bridge.deposits(\n            depositKey\n        );\n        require(deposit.revealedAt != 0, \"Deposit not initialized\");\n\n        (, uint64 finalizedAt) = tbtcVault.optimisticMintingRequests(\n            depositKey\n        );\n\n        require(\n            deposit.sweptAt != 0 || finalizedAt != 0,\n            \"Deposit not finalized by the bridge\"\n        );\n\n        initialDepositAmount = deposit.amount * SATOSHI_MULTIPLIER;\n\n        tbtcAmount = _calculateTbtcAmount(deposit.amount, deposit.treasuryFee);\n\n        extraData = deposit.extraData;\n    }\n\n    /// @notice Calculates the amount of TBTC minted for the deposit.\n    /// @param depositAmountSat Deposit amount in satoshi (1e8 precision).\n    ///        This is the actual amount deposited by the deposit creator, i.e.\n    ///        the gross amount the Bridge's fees are cut from.\n    /// @param depositTreasuryFeeSat Deposit treasury fee in satoshi (1e8 precision).\n    ///        This is an accurate value of the treasury fee that was actually\n    ///        cut upon minting.\n    /// @return tbtcAmount Approximate amount of TBTC minted for the deposit.\n    /// @dev IMPORTANT NOTE: The tbtcAmount returned by this function may\n    ///      not correspond to the actual amount of TBTC minted for the deposit.\n    ///      Although the treasury fee cut upon minting is known precisely,\n    ///      this is not the case for the optimistic minting fee and the Bitcoin\n    ///      transaction fee. To overcome that problem, this function just takes\n    ///      the current maximum allowed values of both fees, at the moment of deposit\n    ///      finalization. For the great majority of the deposits, such an\n    ///      algorithm will return a tbtcAmount slightly lesser than the\n    ///      actual amount of TBTC minted for the deposit. This will cause\n    ///      some TBTC to be left in the contract and ensure there is enough\n    ///      liquidity to finalize the deposit. However, in some rare cases,\n    ///      where the actual values of those fees change between the deposit\n    ///      minting and finalization, the tbtcAmount returned by this function\n    ///      may be greater than the actual amount of TBTC minted for the deposit.\n    ///      If this happens and the reserve coming from previous deposits\n    ///      leftovers does not provide enough liquidity, the deposit will have\n    ///      to wait for finalization until the reserve is refilled by subsequent\n    ///      deposits or a manual top-up. The integrator is responsible for\n    ///      handling such cases.\n    // slither-disable-next-line dead-code\n    function _calculateTbtcAmount(\n        uint64 depositAmountSat,\n        uint64 depositTreasuryFeeSat\n    ) internal view virtual returns (uint256) {\n        // Both deposit amount and treasury fee are in the 1e8 satoshi precision.\n        // We need to convert them to the 1e18 TBTC precision.\n        uint256 amountSubTreasury = (depositAmountSat - depositTreasuryFeeSat) *\n            SATOSHI_MULTIPLIER;\n\n        uint256 omFeeDivisor = tbtcVault.optimisticMintingFeeDivisor();\n        uint256 omFee = omFeeDivisor > 0\n            ? (amountSubTreasury / omFeeDivisor)\n            : 0;\n\n        // The deposit transaction max fee is in the 1e8 satoshi precision.\n        // We need to convert them to the 1e18 TBTC precision.\n        (, , uint64 depositTxMaxFee, ) = bridge.depositParameters();\n        uint256 txMaxFee = depositTxMaxFee * SATOSHI_MULTIPLIER;\n\n        return amountSubTreasury - omFee - txMaxFee;\n    }\n\n    /// @notice Calculates the deposit key for the given funding transaction\n    ///         hash and funding output index.\n    /// @param fundingTxHash Funding transaction hash.\n    /// @param fundingOutputIndex Funding output index.\n    /// @return depositKey Deposit key computed as\n    ///         `keccak256(fundingTxHash | reveal.fundingOutputIndex)`. This\n    ///         key can be used to refer to the deposit in the Bridge and\n    ///         TBTCVault contracts.\n    // slither-disable-next-line dead-code\n    function _calculateDepositKey(\n        bytes32 fundingTxHash,\n        uint32 fundingOutputIndex\n    ) internal pure returns (uint256) {\n        return\n            uint256(\n                keccak256(abi.encodePacked(fundingTxHash, fundingOutputIndex))\n            );\n    }\n\n    /// @notice Calculates the Bitcoin transaction hash for the given Bitcoin\n    ///         transaction data.\n    /// @param txInfo Bitcoin transaction data, see `IBridgeTypes.BitcoinTxInfo` struct.\n    /// @return txHash Bitcoin transaction hash.\n    // slither-disable-next-line dead-code\n    function _calculateBitcoinTxHash(IBridgeTypes.BitcoinTxInfo memory txInfo)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            abi\n                .encodePacked(\n                    txInfo.version,\n                    txInfo.inputVector,\n                    txInfo.outputVector,\n                    txInfo.locktime\n                )\n                .hash256View();\n    }\n\n    /// @notice Returns minimum deposit amount.\n    /// @return Minimum deposit amount. In TBTC token decimals precision.\n    // slither-disable-next-line dead-code\n    function _minDepositAmount() internal view returns (uint256) {\n        // Read tBTC Bridge Deposit Dust Threshold in satoshi precision.\n        (uint64 bridgeDepositDustThresholdSat, , , ) = bridge\n            .depositParameters();\n\n        // Convert tBTC Bridge Deposit Dust Threshold to TBTC token precision.\n        return bridgeDepositDustThresholdSat * SATOSHI_MULTIPLIER;\n    }\n}\n"
    },
    "@keep-network/tbtc-v2/contracts/integrator/IBridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.0;\n\n/// @notice Namespace which groups all types relevant to the IBridge interface.\n/// @dev This is a mirror of the real types used in the Bridge contract.\n///      This way, the `integrator` subpackage does not need to import\n///      anything from the `bridge` subpackage and explicitly depend on it.\n///      This simplifies the dependency graph for integrators.\nlibrary IBridgeTypes {\n    /// @dev See bridge/BitcoinTx.sol#Info\n    struct BitcoinTxInfo {\n        bytes4 version;\n        bytes inputVector;\n        bytes outputVector;\n        bytes4 locktime;\n    }\n\n    /// @dev See bridge/Deposit.sol#DepositRevealInfo\n    struct DepositRevealInfo {\n        uint32 fundingOutputIndex;\n        bytes8 blindingFactor;\n        bytes20 walletPubKeyHash;\n        bytes20 refundPubKeyHash;\n        bytes4 refundLocktime;\n        address vault;\n    }\n\n    /// @dev See bridge/Deposit.sol#DepositRequest\n    struct DepositRequest {\n        address depositor;\n        uint64 amount;\n        uint32 revealedAt;\n        address vault;\n        uint64 treasuryFee;\n        uint32 sweptAt;\n        bytes32 extraData;\n    }\n}\n\n/// @notice Interface of the Bridge contract.\n/// @dev See bridge/Bridge.sol\ninterface IBridge {\n    /// @dev See {Bridge#revealDepositWithExtraData}\n    function revealDepositWithExtraData(\n        IBridgeTypes.BitcoinTxInfo calldata fundingTx,\n        IBridgeTypes.DepositRevealInfo calldata reveal,\n        bytes32 extraData\n    ) external;\n\n    /// @dev See {Bridge#deposits}\n    function deposits(uint256 depositKey)\n        external\n        view\n        returns (IBridgeTypes.DepositRequest memory);\n\n    /// @dev See {Bridge#depositParameters}\n    function depositParameters()\n        external\n        view\n        returns (\n            uint64 depositDustThreshold,\n            uint64 depositTreasuryFeeDivisor,\n            uint64 depositTxMaxFee,\n            uint32 depositRevealAheadPeriod\n        );\n}\n"
    },
    "@keep-network/tbtc-v2/contracts/integrator/ITBTCVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.0;\n\n/// @notice Interface of the TBTCVault contract.\n/// @dev See vault/TBTCVault.sol\ninterface ITBTCVault {\n    /// @dev See {TBTCVault#optimisticMintingRequests}\n    function optimisticMintingRequests(uint256 depositKey)\n        external\n        returns (uint64 requestedAt, uint64 finalizedAt);\n\n    /// @dev See {TBTCVault#optimisticMintingFeeDivisor}\n    function optimisticMintingFeeDivisor() external view returns (uint32);\n\n    /// @dev See {TBTCVault#tbtcToken}\n    function tbtcToken() external view returns (address);\n}\n"
    },
    "@keep-network/tbtc-v2/contracts/l2/L1BitcoinDepositor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity 0.8.17;\n\nimport \"@keep-network/random-beacon/contracts/Reimbursable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../integrator/AbstractTBTCDepositor.sol\";\nimport \"../integrator/IBridge.sol\";\nimport \"../integrator/ITBTCVault.sol\";\nimport \"./Wormhole.sol\";\n\n/// @title L1BitcoinDepositor\n/// @notice This contract is part of the direct bridging mechanism allowing\n///         users to obtain ERC20 TBTC on supported L2 chains, without the need\n///         to interact with the L1 tBTC ledger chain where minting occurs.\n///\n///         `L1BitcoinDepositor` is deployed on the L1 chain and interacts with\n///         their L2 counterpart, the `L2BitcoinDepositor`, deployed on the given\n///         L2 chain. Each `L1BitcoinDepositor` & `L2BitcoinDepositor` pair is\n///         responsible for a specific L2 chain.\n///\n///         The outline of the direct bridging mechanism is as follows:\n///         1. An L2 user issues a Bitcoin funding transaction to a P2(W)SH\n///            deposit address that embeds the `L1BitcoinDepositor` contract\n///            and L2 user addresses. The `L1BitcoinDepositor` contract serves\n///            as the actual depositor on the L1 chain while the L2 user\n///            address is set as the deposit owner who will receive the\n///            minted ERC20 TBTC.\n///         2. The data about the Bitcoin funding transaction and deposit\n///            address are passed to the relayer. In the first iteration of\n///            the direct bridging mechanism, this is achieved using an\n///            on-chain event emitted by the `L2BitcoinDepositor` contract.\n///            Further iterations assumes those data are passed off-chain, e.g.\n///            through a REST API exposed by the relayer.\n///         3. The relayer uses the data to initialize a deposit on the L1\n///            chain by calling the `initializeDeposit` function of the\n///            `L1BitcoinDepositor` contract. The `initializeDeposit` function\n///            reveals the deposit to the tBTC Bridge so minting of ERC20 L1 TBTC\n///            can occur.\n///         4. Once minting is complete, the `L1BitcoinDepositor` contract\n///            receives minted ERC20 L1 TBTC. The relayer then calls the\n///            `finalizeDeposit` function of the `L1BitcoinDepositor` contract\n///            to transfer the minted ERC20 L1 TBTC to the L2 user address. This\n///            is achieved using the Wormhole protocol. First, the `finalizeDeposit`\n///            function initiates a Wormhole token transfer that locks the ERC20\n///            L1 TBTC within the Wormhole Token Bridge contract and assigns\n///            Wormhole-wrapped L2 TBTC to the corresponding `L2WormholeGateway`\n///            contract. Then, `finalizeDeposit` notifies the `L2BitcoinDepositor`\n///            contract by sending a Wormhole message containing the VAA\n///            of the Wormhole token transfer. The `L2BitcoinDepositor` contract\n///            receives the Wormhole message, and calls the `L2WormholeGateway`\n///            contract that redeems Wormhole-wrapped L2 TBTC from the Wormhole\n///            Token Bridge and uses it to mint canonical L2 TBTC to the L2 user\n///            address.\ncontract L1BitcoinDepositor is\n    AbstractTBTCDepositor,\n    OwnableUpgradeable,\n    Reimbursable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Reflects the deposit state:\n    ///         - Unknown deposit has not been initialized yet.\n    ///         - Initialized deposit has been initialized with a call to\n    ///           `initializeDeposit` function and is known to this contract.\n    ///         - Finalized deposit led to TBTC ERC20 minting and was finalized\n    ///           with a call to `finalizeDeposit` function that transferred\n    ///           TBTC ERC20 to the L2 deposit owner.\n    enum DepositState {\n        Unknown,\n        Initialized,\n        Finalized\n    }\n\n    /// @notice Holds information about a deferred gas reimbursement.\n    struct GasReimbursement {\n        /// @notice Receiver that is supposed to receive the reimbursement.\n        address receiver;\n        /// @notice Gas expenditure that is meant to be reimbursed.\n        uint96 gasSpent;\n    }\n\n    /// @notice Holds the deposit state, keyed by the deposit key calculated for\n    ///         the individual deposit during the call to `initializeDeposit`\n    ///         function.\n    mapping(uint256 => DepositState) public deposits;\n    /// @notice ERC20 L1 TBTC token contract.\n    IERC20Upgradeable public tbtcToken;\n    /// @notice `Wormhole` core contract on L1.\n    IWormhole public wormhole;\n    /// @notice `WormholeRelayer` contract on L1.\n    IWormholeRelayer public wormholeRelayer;\n    /// @notice Wormhole `TokenBridge` contract on L1.\n    IWormholeTokenBridge public wormholeTokenBridge;\n    /// @notice tBTC `L2WormholeGateway` contract on the corresponding L2 chain.\n    address public l2WormholeGateway;\n    /// @notice Wormhole chain ID of the corresponding L2 chain.\n    uint16 public l2ChainId;\n    /// @notice tBTC `L2BitcoinDepositor` contract on the corresponding L2 chain.\n    address public l2BitcoinDepositor;\n    /// @notice Gas limit necessary to execute the L2 part of the deposit\n    ///         finalization. This value is used to calculate the payment for\n    ///         the Wormhole Relayer that is responsible to execute the\n    ///         deposit finalization on the corresponding L2 chain. Can be\n    ///         updated by the owner.\n    uint256 public l2FinalizeDepositGasLimit;\n    /// @notice Holds deferred gas reimbursements for deposit initialization\n    ///         (indexed by deposit key). Reimbursement for deposit\n    ///         initialization is paid out upon deposit finalization. This is\n    ///         because the tBTC Bridge accepts all (even invalid) deposits but\n    ///         mints ERC20 TBTC only for the valid ones. Paying out the\n    ///         reimbursement directly upon initialization would make the\n    ///         reimbursement pool vulnerable to malicious actors that could\n    ///         drain it by initializing invalid deposits.\n    mapping(uint256 => GasReimbursement) public gasReimbursements;\n    /// @notice Gas that is meant to balance the overall cost of deposit initialization.\n    ///         Can be updated by the owner based on the current market conditions.\n    uint256 public initializeDepositGasOffset;\n    /// @notice Gas that is meant to balance the overall cost of deposit finalization.\n    ///         Can be updated by the owner based on the current market conditions.\n    uint256 public finalizeDepositGasOffset;\n    /// @notice Set of addresses that are authorized to receive gas reimbursements\n    ///         for deposit initialization and finalization. The authorization is\n    ///         granted by the contract owner.\n    mapping(address => bool) public reimbursementAuthorizations;\n\n    /// @notice **Feature Flag** controlling whether the deposit transaction max fee\n    ///         is **reimbursed** (added to the user’s TBTC) or **deducted**.\n    ///         - `true`  => Add `txMaxFee` to the minted TBTC amount\n    ///         - `false` => Subtract `txMaxFee` from the minted TBTC amount\n    bool public reimburseTxMaxFee;\n\n    event DepositInitialized(\n        uint256 indexed depositKey,\n        address indexed l2DepositOwner,\n        address indexed l1Sender\n    );\n\n    event DepositFinalized(\n        uint256 indexed depositKey,\n        address indexed l2DepositOwner,\n        address indexed l1Sender,\n        uint256 initialAmount,\n        uint256 tbtcAmount\n    );\n\n    event L2FinalizeDepositGasLimitUpdated(uint256 l2FinalizeDepositGasLimit);\n\n    event GasOffsetParametersUpdated(\n        uint256 initializeDepositGasOffset,\n        uint256 finalizeDepositGasOffset\n    );\n\n    event ReimbursementAuthorizationUpdated(\n        address indexed _address,\n        bool authorization\n    );\n\n    /// @notice Emitted whenever the owner toggles the reimbursement of the deposit\n    ///         transaction max fee.\n    event ReimburseTxMaxFeeUpdated(bool reimburseTxMaxFee);\n\n    /// @dev This modifier comes from the `Reimbursable` base contract and\n    ///      must be overridden to protect the `updateReimbursementPool` call.\n    modifier onlyReimbursableAdmin() override {\n        require(msg.sender == owner(), \"Caller is not the owner\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _tbtcBridge,\n        address _tbtcVault,\n        address _wormhole,\n        address _wormholeRelayer,\n        address _wormholeTokenBridge,\n        address _l2WormholeGateway,\n        uint16 _l2ChainId\n    ) external initializer {\n        __AbstractTBTCDepositor_initialize(_tbtcBridge, _tbtcVault);\n        __Ownable_init();\n\n        require(_wormhole != address(0), \"Wormhole address cannot be zero\");\n        require(\n            _wormholeRelayer != address(0),\n            \"WormholeRelayer address cannot be zero\"\n        );\n        require(\n            _wormholeTokenBridge != address(0),\n            \"WormholeTokenBridge address cannot be zero\"\n        );\n        require(\n            _l2WormholeGateway != address(0),\n            \"L2WormholeGateway address cannot be zero\"\n        );\n\n        tbtcToken = IERC20Upgradeable(ITBTCVault(_tbtcVault).tbtcToken());\n        wormhole = IWormhole(_wormhole);\n        wormholeRelayer = IWormholeRelayer(_wormholeRelayer);\n        wormholeTokenBridge = IWormholeTokenBridge(_wormholeTokenBridge);\n        // slither-disable-next-line missing-zero-check\n        l2WormholeGateway = _l2WormholeGateway;\n        l2ChainId = _l2ChainId;\n        l2FinalizeDepositGasLimit = 500_000;\n        initializeDepositGasOffset = 60_000;\n        finalizeDepositGasOffset = 20_000;\n        reimburseTxMaxFee = false;\n    }\n\n    /// @notice Sets the address of the `L2BitcoinDepositor` contract on the\n    ///         corresponding L2 chain. This function solves the chicken-and-egg\n    ///         problem of setting the `L2BitcoinDepositor` contract address\n    ///         on the `L1BitcoinDepositor` contract and vice versa.\n    /// @param _l2BitcoinDepositor Address of the `L2BitcoinDepositor` contract.\n    /// @dev Requirements:\n    ///      - Can be called only by the contract owner,\n    ///      - The address must not be set yet,\n    ///      - The new address must not be 0x0.\n    function attachL2BitcoinDepositor(address _l2BitcoinDepositor)\n        external\n        onlyOwner\n    {\n        require(\n            l2BitcoinDepositor == address(0),\n            \"L2 Bitcoin Depositor already set\"\n        );\n        require(\n            _l2BitcoinDepositor != address(0),\n            \"L2 Bitcoin Depositor must not be 0x0\"\n        );\n        l2BitcoinDepositor = _l2BitcoinDepositor;\n    }\n\n    /// @notice Updates the gas limit necessary to execute the L2 part of the\n    ///         deposit finalization.\n    /// @param _l2FinalizeDepositGasLimit New gas limit.\n    /// @dev Requirements:\n    ///      - Can be called only by the contract owner.\n    function updateL2FinalizeDepositGasLimit(uint256 _l2FinalizeDepositGasLimit)\n        external\n        onlyOwner\n    {\n        l2FinalizeDepositGasLimit = _l2FinalizeDepositGasLimit;\n        emit L2FinalizeDepositGasLimitUpdated(_l2FinalizeDepositGasLimit);\n    }\n\n    /// @notice Updates the values of gas offset parameters.\n    /// @dev Can be called only by the contract owner. The caller is responsible\n    ///      for validating parameters.\n    /// @param _initializeDepositGasOffset New initialize deposit gas offset.\n    /// @param _finalizeDepositGasOffset New finalize deposit gas offset.\n    function updateGasOffsetParameters(\n        uint256 _initializeDepositGasOffset,\n        uint256 _finalizeDepositGasOffset\n    ) external onlyOwner {\n        initializeDepositGasOffset = _initializeDepositGasOffset;\n        finalizeDepositGasOffset = _finalizeDepositGasOffset;\n\n        emit GasOffsetParametersUpdated(\n            _initializeDepositGasOffset,\n            _finalizeDepositGasOffset\n        );\n    }\n\n    /// @notice Updates the reimbursement authorization for the given address.\n    /// @param _address Address to update the authorization for.\n    /// @param authorization New authorization status.\n    /// @dev Requirements:\n    ///      - Can be called only by the contract owner.\n    function updateReimbursementAuthorization(\n        address _address,\n        bool authorization\n    ) external onlyOwner {\n        emit ReimbursementAuthorizationUpdated(_address, authorization);\n        reimbursementAuthorizations[_address] = authorization;\n    }\n\n    /// @notice Toggles whether the deposit transaction max fee is reimbursed\n    ///         or deducted. Only callable by the contract owner.\n    /// @param _reimburseTxMaxFee `true` => reimburse (add) the deposit tx max fee,\n    ///                        `false` => deduct the deposit tx max fee.\n    function setReimburseTxMaxFee(bool _reimburseTxMaxFee) external onlyOwner {\n        reimburseTxMaxFee = _reimburseTxMaxFee;\n        emit ReimburseTxMaxFeeUpdated(_reimburseTxMaxFee);\n    }\n\n    /// @notice Initializes the deposit process on L1 by revealing the deposit\n    ///         data (funding transaction and components of the P2(W)SH deposit\n    ///         address) to the tBTC Bridge. Once tBTC minting is completed,\n    ///         this call should be followed by a call to `finalizeDeposit`.\n    ///         Callers of `initializeDeposit` are eligible for a gas refund\n    ///         that is paid out upon deposit finalization (only if the\n    ///         reimbursement pool is attached and the given caller is\n    ///         authorized for refunds).\n    ///\n    ///         The Bitcoin funding transaction must transfer funds to a P2(W)SH\n    ///         deposit address whose underlying script is built from the\n    ///         following components:\n    ///\n    ///         <depositor-address> DROP\n    ///         <depositor-extra-data> DROP\n    ///         <blinding-factor> DROP\n    ///         DUP HASH160 <signingGroupPubkeyHash> EQUAL\n    ///         IF\n    ///           CHECKSIG\n    ///         ELSE\n    ///           DUP HASH160 <refundPubkeyHash> EQUALVERIFY\n    ///           <locktime> CHECKLOCKTIMEVERIFY DROP\n    ///           CHECKSIG\n    ///         ENDIF\n    ///\n    ///         Where:\n    ///\n    ///         <depositor-address> 20-byte L1 address of the\n    ///         `L1BitcoinDepositor` contract.\n    ///\n    ///         <depositor-extra-data> L2 deposit owner address in the Wormhole\n    ///         format, i.e. 32-byte value left-padded with 0.\n    ///\n    ///         <blinding-factor> 8-byte deposit blinding factor, as used in the\n    ///         tBTC bridge.\n    ///\n    ///         <signingGroupPubkeyHash> The compressed Bitcoin public key (33\n    ///         bytes and 02 or 03 prefix) of the deposit's wallet hashed in the\n    ///         HASH160 Bitcoin opcode style. This must point to the active tBTC\n    ///         bridge wallet.\n    ///\n    ///         <refundPubkeyHash> The compressed Bitcoin public key (33 bytes\n    ///         and 02 or 03 prefix) that can be used to make the deposit refund\n    ///         after the tBTC bridge refund locktime passed. Hashed in the\n    ///         HASH160 Bitcoin opcode style. This is needed only as a security\n    ///         measure protecting the user in case tBTC bridge completely stops\n    ///         functioning.\n    ///\n    ///         <locktime> The Bitcoin script refund locktime (4-byte LE),\n    ///         according to tBTC bridge rules.\n    ///\n    ///         Please consult tBTC `Bridge.revealDepositWithExtraData` function\n    ///         documentation for more information.\n    /// @param fundingTx Bitcoin funding transaction data.\n    /// @param reveal Deposit reveal data.\n    /// @param l2DepositOwner Address of the L2 deposit owner.\n    /// @dev Requirements:\n    ///      - The L2 deposit owner address must not be 0x0,\n    ///      - The function can be called only one time for the given Bitcoin\n    ///        funding transaction,\n    ///      - The L2 deposit owner must be embedded in the Bitcoin P2(W)SH\n    ///        deposit script as the <depositor-extra-data> field. The 20-byte\n    ///        address must be expressed as a 32-byte value left-padded with 0.\n    ///        If the value in the Bitcoin script and the value passed as\n    ///        parameter do not match, the function will revert,\n    ///      - All the requirements of tBTC Bridge.revealDepositWithExtraData\n    ///        must be met.\n    function initializeDeposit(\n        IBridgeTypes.BitcoinTxInfo calldata fundingTx,\n        IBridgeTypes.DepositRevealInfo calldata reveal,\n        address l2DepositOwner\n    ) external {\n        uint256 gasStart = gasleft();\n\n        require(\n            l2DepositOwner != address(0),\n            \"L2 deposit owner must not be 0x0\"\n        );\n\n        // Convert the L2 deposit owner address into the Wormhole format and\n        // encode it as deposit extra data.\n        bytes32 extraData = WormholeUtils.toWormholeAddress(l2DepositOwner);\n\n        // Input parameters do not have to be validated in any way.\n        // The tBTC Bridge is responsible for validating whether the provided\n        // Bitcoin funding transaction transfers funds to the P2(W)SH deposit\n        // address built from the reveal data. Despite the tBTC Bridge accepts\n        // all transactions that meet the format requirements, it mints ERC20\n        // L1 TBTC only for the ones that actually occurred on the Bitcoin\n        // network and gathered enough confirmations.\n        (uint256 depositKey, ) = _initializeDeposit(\n            fundingTx,\n            reveal,\n            extraData\n        );\n\n        require(\n            deposits[depositKey] == DepositState.Unknown,\n            \"Wrong deposit state\"\n        );\n\n        // slither-disable-next-line reentrancy-benign\n        deposits[depositKey] = DepositState.Initialized;\n\n        // slither-disable-next-line reentrancy-events\n        emit DepositInitialized(depositKey, l2DepositOwner, msg.sender);\n\n        // Record a deferred gas reimbursement if the reimbursement pool is\n        // attached and the caller is authorized to receive reimbursements.\n        if (\n            address(reimbursementPool) != address(0) &&\n            reimbursementAuthorizations[msg.sender]\n        ) {\n            uint256 gasSpent = (gasStart - gasleft()) +\n                initializeDepositGasOffset;\n\n            // Should not happen as long as initializeDepositGasOffset is\n            // set to a reasonable value. If it happens, it's better to\n            // omit the reimbursement than to revert the transaction.\n            if (gasSpent > type(uint96).max) {\n                return;\n            }\n\n            // Do not issue a reimbursement immediately. Record\n            // a deferred reimbursement that will be paid out upon deposit\n            // finalization. This is because the tBTC Bridge accepts all\n            // (even invalid) deposits but mints ERC20 TBTC only for the valid\n            // ones. Paying out the reimbursement directly upon initialization\n            // would make the reimbursement pool vulnerable to malicious actors\n            // that could drain it by initializing invalid deposits.\n            // slither-disable-next-line reentrancy-benign\n            gasReimbursements[depositKey] = GasReimbursement({\n                receiver: msg.sender,\n                gasSpent: uint96(gasSpent)\n            });\n        }\n    }\n\n    /// @notice Finalizes the deposit process by transferring ERC20 L1 TBTC\n    ///         to the L2 deposit owner. This function should be called after\n    ///         the deposit was initialized with a call to `initializeDeposit`\n    ///         function and after ERC20 L1 TBTC was minted by the tBTC Bridge\n    ///         to the `L1BitcoinDepositor` contract. Please note several hours\n    ///         may pass between `initializeDeposit`and `finalizeDeposit`.\n    ///         If the reimbursement pool is attached, the function pays out\n    ///         a gas and call's value refund to the caller (if the given\n    ///         caller is authorized for refunds) as well as the deferred gas\n    ///         refund to the caller of `initializeDeposit` corresponding to\n    ///         the finalized deposit.\n    /// @param depositKey The deposit key, as emitted in the `DepositInitialized`\n    ///        event emitted by the `initializeDeposit` function for the deposit.\n    /// @dev Requirements:\n    ///      - `initializeDeposit` was called for the given deposit before,\n    ///      - ERC20 L1 TBTC was minted by tBTC Bridge to this contract,\n    ///      - The function was not called for the given deposit before,\n    ///      - The call must carry a payment for the Wormhole Relayer that\n    ///        is responsible for executing the deposit finalization on the\n    ///        corresponding L2 chain. The payment must be equal to the\n    ///        value returned by the `quoteFinalizeDeposit` function.\n    function finalizeDeposit(uint256 depositKey) external payable {\n        uint256 gasStart = gasleft();\n\n        require(\n            deposits[depositKey] == DepositState.Initialized,\n            \"Wrong deposit state\"\n        );\n\n        deposits[depositKey] = DepositState.Finalized;\n\n        (\n            uint256 initialDepositAmount,\n            uint256 tbtcAmount,\n            // Deposit extra data is actually the L2 deposit owner\n            // address in Wormhole format.\n            bytes32 l2DepositOwner\n        ) = _finalizeDeposit(depositKey);\n\n        // ----------------------------\n        // Reimburse or Deduct Max Fee\n        // ----------------------------\n        if (reimburseTxMaxFee) {\n            // Retrieve deposit tx max fee in 1e8 sat precision -> scale it to 1e18.\n            (, , uint64 depositTxMaxFee, ) = bridge.depositParameters();\n            uint256 txMaxFee = depositTxMaxFee * SATOSHI_MULTIPLIER;\n            // The DAO is \"refunding\" it by adding it to the TBTC minted.\n            tbtcAmount += txMaxFee;\n        }\n\n        // slither-disable-next-line reentrancy-events\n        emit DepositFinalized(\n            depositKey,\n            WormholeUtils.fromWormholeAddress(l2DepositOwner),\n            msg.sender,\n            initialDepositAmount,\n            tbtcAmount\n        );\n\n        _transferTbtc(tbtcAmount, l2DepositOwner);\n\n        // `ReimbursementPool` calls the untrusted receiver address using a\n        // low-level call. Reentrancy risk is mitigated by making sure that\n        // `ReimbursementPool.refund` is a non-reentrant function and executing\n        // reimbursements as the last step of the deposit finalization.\n        if (address(reimbursementPool) != address(0)) {\n            // If there is a deferred reimbursement for this deposit\n            // initialization, pay it out now. No need to check reimbursement\n            // authorization for the initialization caller. If the deferred\n            // reimbursement is here, that implies the caller was authorized\n            // to receive it.\n            GasReimbursement memory reimbursement = gasReimbursements[\n                depositKey\n            ];\n            if (reimbursement.receiver != address(0)) {\n                delete gasReimbursements[depositKey];\n\n                reimbursementPool.refund(\n                    reimbursement.gasSpent,\n                    reimbursement.receiver\n                );\n            }\n\n            // Pay out the reimbursement for deposit finalization if the caller\n            // is authorized to receive reimbursements.\n            if (reimbursementAuthorizations[msg.sender]) {\n                // As this call is payable and this transaction carries out a\n                // msg.value that covers Wormhole cost, we need to reimburse\n                // that as well. However, the `ReimbursementPool` issues refunds\n                // based on gas spent. We need to convert msg.value accordingly\n                // using the `_refundToGasSpent` function.\n                uint256 msgValueOffset = _refundToGasSpent(msg.value);\n                reimbursementPool.refund(\n                    (gasStart - gasleft()) +\n                        msgValueOffset +\n                        finalizeDepositGasOffset,\n                    msg.sender\n                );\n            }\n        }\n    }\n\n    /// @notice The `ReimbursementPool` contract issues refunds based on\n    ///         gas spent. If there is a need to get a specific refund based\n    ///         on WEI value, such a value must be first converted to gas spent.\n    ///         This function does such a conversion.\n    /// @param refund Refund value in WEI.\n    /// @return Refund value as gas spent.\n    /// @dev This function is the reverse of the logic used\n    ///      within `ReimbursementPool.refund`.\n    function _refundToGasSpent(uint256 refund) internal returns (uint256) {\n        uint256 maxGasPrice = reimbursementPool.maxGasPrice();\n        uint256 staticGas = reimbursementPool.staticGas();\n\n        uint256 gasPrice = tx.gasprice < maxGasPrice\n            ? tx.gasprice\n            : maxGasPrice;\n\n        // Should not happen but check just in case of weird ReimbursementPool\n        // configuration.\n        if (gasPrice == 0) {\n            return 0;\n        }\n\n        uint256 gasSpent = (refund / gasPrice);\n\n        // Should not happen but check just in case of weird ReimbursementPool\n        // configuration.\n        if (staticGas > gasSpent) {\n            return 0;\n        }\n\n        return gasSpent - staticGas;\n    }\n\n    /// @notice Quotes the payment that must be attached to the `finalizeDeposit`\n    ///         function call. The payment is necessary to cover the cost of\n    ///         the Wormhole Relayer that is responsible for executing the\n    ///         deposit finalization on the corresponding L2 chain.\n    /// @return cost The cost of the `finalizeDeposit` function call in WEI.\n    function quoteFinalizeDeposit() external view returns (uint256 cost) {\n        cost = _quoteFinalizeDeposit(wormhole.messageFee());\n    }\n\n    /// @notice Internal version of the `quoteFinalizeDeposit` function that\n    ///         works with a custom Wormhole message fee.\n    /// @param messageFee Custom Wormhole message fee.\n    /// @return cost The cost of the `finalizeDeposit` function call in WEI.\n    /// @dev Implemented based on examples presented as part of the Wormhole SDK:\n    ///      https://github.com/wormhole-foundation/hello-token/blob/8ec757248788dc12183f13627633e1d6fd1001bb/src/example-extensions/HelloTokenWithoutSDK.sol#L23\n    function _quoteFinalizeDeposit(uint256 messageFee)\n        internal\n        view\n        returns (uint256 cost)\n    {\n        // Cost of delivering token and payload to `l2ChainId`.\n        (uint256 deliveryCost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\n            l2ChainId,\n            0,\n            l2FinalizeDepositGasLimit\n        );\n\n        // Total cost = delivery cost + cost of publishing the `sending token`\n        // Wormhole message.\n        cost = deliveryCost + messageFee;\n    }\n\n    /// @notice Transfers ERC20 L1 TBTC to the L2 deposit owner using the Wormhole\n    ///         protocol. The function initiates a Wormhole token transfer that\n    ///         locks the ERC20 L1 TBTC within the Wormhole Token Bridge contract\n    ///         and assigns Wormhole-wrapped L2 TBTC to the corresponding\n    ///         `L2WormholeGateway` contract. Then, the function notifies the\n    ///         `L2BitcoinDepositor` contract by sending a Wormhole message\n    ///         containing the VAA of the Wormhole token transfer. The\n    ///         `L2BitcoinDepositor` contract receives the Wormhole message,\n    ///         and calls the `L2WormholeGateway` contract that redeems\n    ///         Wormhole-wrapped L2 TBTC from the Wormhole Token Bridge and\n    ///         uses it to mint canonical L2 TBTC to the L2 deposit owner address.\n    /// @param amount Amount of TBTC L1 ERC20 to transfer (1e18 precision).\n    /// @param l2Receiver Address of the L2 deposit owner.\n    /// @dev Requirements:\n    ///      - The normalized amount (1e8 precision) must be greater than 0,\n    ///      - The appropriate payment for the Wormhole Relayer must be\n    ///        attached to the call (as calculated by `quoteFinalizeDeposit`).\n    /// @dev Implemented based on examples presented as part of the Wormhole SDK:\n    ///      https://github.com/wormhole-foundation/hello-token/blob/8ec757248788dc12183f13627633e1d6fd1001bb/src/example-extensions/HelloTokenWithoutSDK.sol#L29\n    function _transferTbtc(uint256 amount, bytes32 l2Receiver) internal {\n        // Wormhole supports the 1e8 precision at most. TBTC is 1e18 so\n        // the amount needs to be normalized.\n        amount = WormholeUtils.normalize(amount);\n\n        require(amount > 0, \"Amount too low to bridge\");\n\n        // Cost of requesting a `finalizeDeposit` message to be sent to\n        //  `l2ChainId` with a gasLimit of `l2FinalizeDepositGasLimit`.\n        uint256 wormholeMessageFee = wormhole.messageFee();\n        uint256 cost = _quoteFinalizeDeposit(wormholeMessageFee);\n\n        require(msg.value == cost, \"Payment for Wormhole Relayer is too low\");\n\n        // The Wormhole Token Bridge will pull the TBTC amount\n        // from this contract. We need to approve the transfer first.\n        tbtcToken.safeIncreaseAllowance(address(wormholeTokenBridge), amount);\n\n        // Initiate a Wormhole token transfer that will lock L1 TBTC within\n        // the Wormhole Token Bridge contract and assign Wormhole-wrapped\n        // L2 TBTC to the corresponding `L2WormholeGateway` contract.\n        // slither-disable-next-line arbitrary-send-eth\n        uint64 transferSequence = wormholeTokenBridge.transferTokensWithPayload{\n            value: wormholeMessageFee\n        }(\n            address(tbtcToken),\n            amount,\n            l2ChainId,\n            WormholeUtils.toWormholeAddress(l2WormholeGateway),\n            0, // Nonce is a free field that is not relevant in this context.\n            abi.encode(l2Receiver) // Set the L2 receiver address as the transfer payload.\n        );\n\n        // Construct the VAA key corresponding to the above Wormhole token transfer.\n        WormholeTypes.VaaKey[]\n            memory additionalVaas = new WormholeTypes.VaaKey[](1);\n        additionalVaas[0] = WormholeTypes.VaaKey({\n            chainId: wormhole.chainId(),\n            emitterAddress: WormholeUtils.toWormholeAddress(\n                address(wormholeTokenBridge)\n            ),\n            sequence: transferSequence\n        });\n\n        // The Wormhole token transfer initiated above must be finalized on\n        // the L2 chain. We achieve that by sending the transfer's VAA to the\n        // `L2BitcoinDepositor` contract. Once, the `L2BitcoinDepositor`\n        // contract receives it, it calls the `L2WormholeGateway` contract\n        // that redeems Wormhole-wrapped L2 TBTC from the Wormhole Token\n        // Bridge and use it to mint canonical L2 TBTC to the receiver address.\n        // slither-disable-next-line arbitrary-send-eth,unused-return\n        wormholeRelayer.sendVaasToEvm{value: cost - wormholeMessageFee}(\n            l2ChainId,\n            l2BitcoinDepositor,\n            bytes(\"\"), // No payload needed. The L2 receiver address is already encoded in the Wormhole token transfer payload.\n            0, // No receiver value needed.\n            l2FinalizeDepositGasLimit,\n            additionalVaas,\n            l2ChainId, // Set the L2 chain as the refund chain to avoid cross-chain refunds.\n            msg.sender // Set the caller as the refund receiver.\n        );\n    }\n}\n"
    },
    "@keep-network/tbtc-v2/contracts/l2/L2BitcoinDepositor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../integrator/IBridge.sol\";\nimport \"./Wormhole.sol\";\n\n/// @title IL2WormholeGateway\n/// @notice Interface to the `L2WormholeGateway` contract.\ninterface IL2WormholeGateway {\n    /// @dev See ./L2WormholeGateway.sol#receiveTbtc\n    function receiveTbtc(bytes memory vaa) external;\n}\n\n/// @title L2BitcoinDepositor\n/// @notice This contract is part of the direct bridging mechanism allowing\n///         users to obtain ERC20 TBTC on supported L2 chains, without the need\n///         to interact with the L1 tBTC ledger chain where minting occurs.\n///\n///         `L2BitcoinDepositor` is deployed on the L2 chain and interacts with\n///         their L1 counterpart, the `L1BitcoinDepositor`, deployed on the\n///         L1 tBTC ledger chain. Each `L1BitcoinDepositor` & `L2BitcoinDepositor`\n///         pair is responsible for a specific L2 chain.\n///\n///         Please consult the `L1BitcoinDepositor` docstring for an\n///         outline of the direct bridging mechanism\n// slither-disable-next-line locked-ether\ncontract L2BitcoinDepositor is IWormholeReceiver, OwnableUpgradeable {\n    /// @notice `WormholeRelayer` contract on L2.\n    IWormholeRelayer public wormholeRelayer;\n    /// @notice tBTC `L2WormholeGateway` contract on L2.\n    IL2WormholeGateway public l2WormholeGateway;\n    /// @notice Wormhole chain ID of the corresponding L1 chain.\n    uint16 public l1ChainId;\n    /// @notice tBTC `L1BitcoinDepositor` contract on the corresponding L1 chain.\n    address public l1BitcoinDepositor;\n\n    event DepositInitialized(\n        IBridgeTypes.BitcoinTxInfo fundingTx,\n        IBridgeTypes.DepositRevealInfo reveal,\n        address indexed l2DepositOwner,\n        address indexed l2Sender\n    );\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _wormholeRelayer,\n        address _l2WormholeGateway,\n        uint16 _l1ChainId\n    ) external initializer {\n        __Ownable_init();\n\n        require(\n            _wormholeRelayer != address(0),\n            \"WormholeRelayer address cannot be zero\"\n        );\n        require(\n            _l2WormholeGateway != address(0),\n            \"L2WormholeGateway address cannot be zero\"\n        );\n\n        wormholeRelayer = IWormholeRelayer(_wormholeRelayer);\n        l2WormholeGateway = IL2WormholeGateway(_l2WormholeGateway);\n        l1ChainId = _l1ChainId;\n    }\n\n    /// @notice Sets the address of the `L1BitcoinDepositor` contract on the\n    ///         corresponding L1 chain. This function solves the chicken-and-egg\n    ///         problem of setting the `L1BitcoinDepositor` contract address\n    ///         on the `L2BitcoinDepositor` contract and vice versa.\n    /// @param _l1BitcoinDepositor Address of the `L1BitcoinDepositor` contract.\n    /// @dev Requirements:\n    ///      - Can be called only by the contract owner,\n    ///      - The address must not be set yet,\n    ///      - The new address must not be 0x0.\n    function attachL1BitcoinDepositor(address _l1BitcoinDepositor)\n        external\n        onlyOwner\n    {\n        require(\n            l1BitcoinDepositor == address(0),\n            \"L1 Bitcoin Depositor already set\"\n        );\n        require(\n            _l1BitcoinDepositor != address(0),\n            \"L1 Bitcoin Depositor must not be 0x0\"\n        );\n        l1BitcoinDepositor = _l1BitcoinDepositor;\n    }\n\n    /// @notice Initializes the deposit process on L2 by emitting an event\n    ///         containing the deposit data (funding transaction and\n    ///         components of the P2(W)SH deposit address). The event is\n    ///         supposed to be picked up by the relayer and used to initialize\n    ///         the deposit on L1 through the `L1BitcoinDepositor` contract.\n    /// @param fundingTx Bitcoin funding transaction data.\n    /// @param reveal Deposit reveal data.\n    /// @param l2DepositOwner Address of the L2 deposit owner.\n    /// @dev The alternative approach of using Wormhole Relayer to send the\n    ///      deposit data to L1 was considered. However, it turned out to be\n    ///      too expensive. For example, relying deposit data from Base L2 to\n    ///      Ethereum L1 costs around ~0.045 ETH (~170 USD at the moment of writing).\n    ///      Moreover, the next iteration of the direct bridging mechanism\n    ///      assumes that no L2 transaction will be required to initialize the\n    ///      deposit and the relayer should obtain the deposit data off-chain.\n    ///      There is a high chance this function will be removed then.\n    ///      That said, there was no sense to explore another cross-chain\n    ///      messaging solutions. Relying on simple on-chain event and custom\n    ///      off-chain relayer seems to be the most reasonable way to go. It\n    ///      also aligns with the future direction of the direct bridging mechanism.\n    function initializeDeposit(\n        IBridgeTypes.BitcoinTxInfo calldata fundingTx,\n        IBridgeTypes.DepositRevealInfo calldata reveal,\n        address l2DepositOwner\n    ) external {\n        emit DepositInitialized(fundingTx, reveal, l2DepositOwner, msg.sender);\n    }\n\n    /// @notice Receives Wormhole messages originating from the corresponding\n    ///         `L1BitcoinDepositor` contract that lives on the L1 chain.\n    ///         Messages are issued upon deposit finalization on L1 and\n    ///         are supposed to carry the VAA of the Wormhole token transfer of\n    ///         ERC20 L1 TBTC to the L2 chain. This contract performs some basic\n    ///         checks and forwards the VAA to the `L2WormholeGateway` contract\n    ///         that is authorized to withdraw the Wormhole-wrapped L2 TBTC\n    ///         from the Wormhole Token Bridge (representing the ERC20 TBTC\n    ///         locked on L1) and use it to mint the canonical L2 TBTC for the\n    ///         deposit owner.\n    /// @param additionalVaas Additional VAAs that are part of the Wormhole message.\n    /// @param sourceAddress Address of the source of the message (in Wormhole format).\n    /// @param sourceChain Wormhole chain ID of the source chain.\n    /// @dev Requirements:\n    ///      - Can be called only by the Wormhole Relayer contract,\n    ///      - The source chain must be the expected L1 chain,\n    ///      - The source address must be the corresponding\n    ///        `L1BitcoinDepositor` contract,\n    ///      - The message must carry exactly 1 additional VAA key representing\n    ///        the token transfer.\n    function receiveWormholeMessages(\n        bytes memory,\n        bytes[] memory additionalVaas,\n        bytes32 sourceAddress,\n        uint16 sourceChain,\n        bytes32\n    ) external payable {\n        require(\n            msg.sender == address(wormholeRelayer),\n            \"Caller is not Wormhole Relayer\"\n        );\n\n        require(\n            sourceChain == l1ChainId,\n            \"Source chain is not the expected L1 chain\"\n        );\n\n        require(\n            WormholeUtils.fromWormholeAddress(sourceAddress) ==\n                l1BitcoinDepositor,\n            \"Source address is not the expected L1 Bitcoin depositor\"\n        );\n\n        require(\n            additionalVaas.length == 1,\n            \"Expected 1 additional VAA key for token transfer\"\n        );\n\n        l2WormholeGateway.receiveTbtc(additionalVaas[0]);\n    }\n}\n"
    },
    "@keep-network/tbtc-v2/contracts/l2/L2TBTC.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/// @title L2TBTC\n/// @notice Canonical L2/sidechain token implementation. tBTC token is minted on\n///         L1 and locked there to be moved to L2/sidechain. By deploying\n///         a canonical token on each L2/sidechain, we can ensure the supply of\n///         tBTC remains sacrosanct, while enabling quick, interoperable\n///         cross-chain bridges and localizing ecosystem risk.\n///\n///         This contract is flexible enough to:\n///         - Delegate minting authority to a native bridge on the chain, if\n///           present.\n///         - Delegate minting authority to a short list of ecosystem bridges.\n///         - Have mints and burns paused by any one of n guardians, allowing\n///           avoidance of contagion in case of a chain- or bridge-specific\n///           incident.\n///         - Be governed and upgradeable.\n///\n///         The token is burnable by the token holder and supports EIP2612\n///         permits. Token holder can authorize a transfer of their token with\n///         a signature conforming EIP712 standard instead of an on-chain\n///         transaction from their address. Anyone can submit this signature on\n///         the user's behalf by calling the permit function, paying gas fees,\n///         and possibly performing other actions in the same transaction.\n///         The governance can recover ERC20 and ERC721 tokens sent mistakenly\n///         to L2TBTC token contract.\ncontract L2TBTC is\n    ERC20Upgradeable,\n    ERC20BurnableUpgradeable,\n    ERC20PermitUpgradeable,\n    OwnableUpgradeable,\n    PausableUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Indicates if the given address is a minter. Only minters can\n    ///         mint the token.\n    mapping(address => bool) public isMinter;\n\n    /// @notice List of all minters.\n    address[] public minters;\n\n    /// @notice Indicates if the given address is a guardian. Only guardians can\n    ///         pause token mints and burns.\n    mapping(address => bool) public isGuardian;\n\n    /// @notice List of all guardians.\n    address[] public guardians;\n\n    event MinterAdded(address indexed minter);\n    event MinterRemoved(address indexed minter);\n\n    event GuardianAdded(address indexed guardian);\n    event GuardianRemoved(address indexed guardian);\n\n    modifier onlyMinter() {\n        require(isMinter[msg.sender], \"Caller is not a minter\");\n        _;\n    }\n\n    modifier onlyGuardian() {\n        require(isGuardian[msg.sender], \"Caller is not a guardian\");\n        _;\n    }\n\n    /// @notice Initializes the token contract.\n    /// @param _name The name of the token.\n    /// @param _symbol The symbol of the token, usually a shorter version of the\n    ///        name.\n    function initialize(string memory _name, string memory _symbol)\n        external\n        initializer\n    {\n        // OpenZeppelin upgradeable contracts documentation says:\n        //\n        // \"Use with multiple inheritance requires special care. Initializer\n        // functions are not linearized by the compiler like constructors.\n        // Because of this, each __{ContractName}_init function embeds the\n        // linearized calls to all parent initializers. As a consequence,\n        // calling two of these init functions can potentially initialize the\n        // same contract twice.\"\n        //\n        // Note that ERC20 extensions do not linearize calls to ERC20Upgradeable\n        // initializer so we call all extension initializers individually. At\n        // the same time, ERC20PermitUpgradeable does linearize the call to\n        // EIP712Upgradeable so we are not using the unchained initializer\n        // versions.\n        __ERC20_init(_name, _symbol);\n        __ERC20Burnable_init();\n        __ERC20Permit_init(_name);\n        __Ownable_init();\n        __Pausable_init();\n    }\n\n    /// @notice Adds the address to the minters list.\n    /// @dev Requirements:\n    ///      - The caller must be the contract owner.\n    ///      - `minter` must not be a minter address already.\n    /// @param minter The address to be added as a minter.\n    function addMinter(address minter) external onlyOwner {\n        require(!isMinter[minter], \"This address is already a minter\");\n        isMinter[minter] = true;\n        minters.push(minter);\n        emit MinterAdded(minter);\n    }\n\n    /// @notice Removes the address from the minters list.\n    /// @dev Requirements:\n    ///      - The caller must be the contract owner.\n    ///      - `minter` must be a minter address.\n    /// @param minter The address to be removed from the minters list.\n    function removeMinter(address minter) external onlyOwner {\n        require(isMinter[minter], \"This address is not a minter\");\n        delete isMinter[minter];\n\n        // We do not expect too many minters so a simple loop is safe.\n        for (uint256 i = 0; i < minters.length; i++) {\n            if (minters[i] == minter) {\n                minters[i] = minters[minters.length - 1];\n                // slither-disable-next-line costly-loop\n                minters.pop();\n                break;\n            }\n        }\n\n        emit MinterRemoved(minter);\n    }\n\n    /// @notice Adds the address to the guardians list.\n    /// @dev Requirements:\n    ///      - The caller must be the contract owner.\n    ///      - `guardian` must not be a guardian address already.\n    /// @param guardian The address to be added as a guardian.\n    function addGuardian(address guardian) external onlyOwner {\n        require(!isGuardian[guardian], \"This address is already a guardian\");\n        isGuardian[guardian] = true;\n        guardians.push(guardian);\n        emit GuardianAdded(guardian);\n    }\n\n    /// @notice Removes the address from the guardians list.\n    /// @dev Requirements:\n    ///      - The caller must be the contract owner.\n    ///      - `guardian` must be a guardian address.\n    /// @param guardian The address to be removed from the guardians list.\n    function removeGuardian(address guardian) external onlyOwner {\n        require(isGuardian[guardian], \"This address is not a guardian\");\n        delete isGuardian[guardian];\n\n        // We do not expect too many guardians so a simple loop is safe.\n        for (uint256 i = 0; i < guardians.length; i++) {\n            if (guardians[i] == guardian) {\n                guardians[i] = guardians[guardians.length - 1];\n                // slither-disable-next-line costly-loop\n                guardians.pop();\n                break;\n            }\n        }\n\n        emit GuardianRemoved(guardian);\n    }\n\n    /// @notice Allows the governance of the token contract to recover any ERC20\n    ///         sent mistakenly to the token contract address.\n    /// @param token The address of the token to be recovered.\n    /// @param recipient The token recipient address that will receive recovered\n    ///        tokens.\n    /// @param amount The amount to be recovered.\n    function recoverERC20(\n        IERC20Upgradeable token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner {\n        token.safeTransfer(recipient, amount);\n    }\n\n    /// @notice Allows the governance of the token contract to recover any\n    ///         ERC721 sent mistakenly to the token contract address.\n    /// @param token The address of the token to be recovered.\n    /// @param recipient The token recipient address that will receive the\n    ///        recovered token.\n    /// @param tokenId The ID of the ERC721 token to be recovered.\n    function recoverERC721(\n        IERC721Upgradeable token,\n        address recipient,\n        uint256 tokenId,\n        bytes calldata data\n    ) external onlyOwner {\n        token.safeTransferFrom(address(this), recipient, tokenId, data);\n    }\n\n    /// @notice Allows one of the guardians to pause mints and burns allowing\n    ///         avoidance of contagion in case of a chain- or bridge-specific\n    ///         incident.\n    /// @dev Requirements:\n    ///      - The caller must be a guardian.\n    ///      - The contract must not be already paused.\n    function pause() external onlyGuardian {\n        _pause();\n    }\n\n    /// @notice Allows the governance to unpause mints and burns previously\n    ///         paused by one of the guardians.\n    /// @dev Requirements:\n    ///      - The caller must be the contract owner.\n    ///      - The contract must be paused.\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /// @notice Allows one of the minters to mint `amount` tokens and assign\n    ///         them to `account`, increasing the total supply. Emits\n    ///         a `Transfer` event with `from` set to the zero address.\n    /// @dev Requirements:\n    ///      - The caller must be a minter.\n    ///      - `account` must not be the zero address.\n    /// @param account The address to receive tokens.\n    /// @param amount The amount of token to be minted.\n    function mint(address account, uint256 amount)\n        external\n        whenNotPaused\n        onlyMinter\n    {\n        _mint(account, amount);\n    }\n\n    /// @notice Destroys `amount` tokens from the caller. Emits a `Transfer`\n    ///         event with `to` set to the zero address.\n    /// @dev Requirements:\n    ///      - The caller must have at least `amount` tokens.\n    /// @param amount The amount of token to be burned.\n    function burn(uint256 amount) public override whenNotPaused {\n        super.burn(amount);\n    }\n\n    /// @notice Destroys `amount` tokens from `account`, deducting from the\n    ///         caller's allowance. Emits a `Transfer` event with `to` set to\n    ///         the zero address.\n    /// @dev Requirements:\n    ///      - The che caller must have allowance for `accounts`'s tokens of at\n    ///        least `amount`.\n    ///      - `account` must not be the zero address.\n    ///      - `account` must have at least `amount` tokens.\n    /// @param account The address owning tokens to be burned.\n    /// @param amount The amount of token to be burned.\n    function burnFrom(address account, uint256 amount)\n        public\n        override\n        whenNotPaused\n    {\n        super.burnFrom(account, amount);\n    }\n\n    /// @notice Allows to fetch a list of all minters.\n    function getMinters() external view returns (address[] memory) {\n        return minters;\n    }\n\n    /// @notice Allows to fetch a list of all guardians.\n    function getGuardians() external view returns (address[] memory) {\n        return guardians;\n    }\n}\n"
    },
    "@keep-network/tbtc-v2/contracts/l2/L2WormholeGateway.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"./Wormhole.sol\";\nimport \"./L2TBTC.sol\";\n\n/// @title L2WormholeGateway\n/// @notice Selected cross-ecosystem bridges are given the minting authority for\n///         tBTC token on L2 and sidechains. This contract gives a minting\n///         authority to the Wormhole Bridge.\n///\n///         The process of bridging from L1 to L2 (or sidechain) looks as\n///         follows:\n///         1. There is a tBTC holder on L1. The holder goes to the Wormhole\n///            Portal and selects the chain they want to bridge to.\n///         2. The holder submits one transaction to L1 locking their tBTC\n///            tokens in the bridge’s smart contract. After the transaction is\n///            mined, they wait about 15 minutes for the Ethereum block\n///            finality.\n///         3. The holder submits one transaction to L2 that is minting tokens.\n///            After that transaction is mined, they have their tBTC on L2.\n///\n///         The process of bridging from L2 (or sidechain) to L1 looks as\n///         follows:\n///         1. There is a tBTC holder on L2. That holder goes to the Wormhole\n///            Portal and selects one of the L2 chains they want to bridge from.\n///         2. The holder submits one transaction to L2 that is burning the\n///            token. After the transaction is mined, they wait about 15 minutes\n///            for the L2 block finality.\n///         3. The holder submits one transaction to L1 unlocking their tBTC\n///            tokens from the bridge’s smart contract. After that transaction\n///            is mined, they have their tBTC on L1.\n///\n///         This smart contract is integrated with step 3 of L1->L2 bridging and\n///         step 1 of L2->L1 or L2->L2 bridging. When the user redeems token on\n///         L2, this contract receives the Wormhole tBTC representation and\n///         mints the canonical tBTC in an equal amount. When user sends their\n///         token from L1, this contract burns the canonical tBTC and sends\n///         Wormhole tBTC representation through the bridge in an equal amount.\n/// @dev This contract is supposed to be deployed behind a transparent\n///      upgradeable proxy.\n// slither-disable-next-line missing-inheritance\ncontract L2WormholeGateway is\n    Initializable,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @notice Reference to the Wormhole Token Bridge contract.\n    IWormholeTokenBridge public bridge;\n\n    /// @notice Wormhole tBTC token representation.\n    IERC20Upgradeable public bridgeToken;\n\n    /// @notice Canonical tBTC token.\n    L2TBTC public tbtc;\n\n    /// @notice Maps Wormhole chain ID to the Wormhole tBTC gateway address on\n    ///         that chain. For example, this chain's ID should be mapped to\n    ///         this contract's address. If there is no Wormhole tBTC gateway\n    ///         address on the given chain, there is no entry in this mapping.\n    ///         The mapping holds addresses in a Wormhole-specific format, where\n    ///         Ethereum address is left-padded with zeros.\n    mapping(uint16 => bytes32) public gateways;\n\n    /// @notice Minting limit for this gateway. Useful for early days of testing\n    ///         the system. The gateway can not mint more canonical tBTC than\n    ///         this limit.\n    uint256 public mintingLimit;\n\n    /// @notice The amount of tBTC minted by this contract. tBTC burned by this\n    ///         contract decreases this amount.\n    uint256 public mintedAmount;\n\n    event WormholeTbtcReceived(address receiver, uint256 amount);\n\n    event WormholeTbtcSent(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 gateway,\n        bytes32 recipient,\n        uint256 arbiterFee,\n        uint32 nonce\n    );\n\n    event WormholeTbtcDeposited(address depositor, uint256 amount);\n\n    event GatewayAddressUpdated(uint16 chainId, bytes32 gateway);\n\n    event MintingLimitUpdated(uint256 mintingLimit);\n\n    function initialize(\n        IWormholeTokenBridge _bridge,\n        IERC20Upgradeable _bridgeToken,\n        L2TBTC _tbtc\n    ) external initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        require(\n            address(_bridge) != address(0),\n            \"Wormhole bridge address must not be 0x0\"\n        );\n        require(\n            address(_bridgeToken) != address(0),\n            \"Bridge token address must not be 0x0\"\n        );\n        require(\n            address(_tbtc) != address(0),\n            \"L2TBTC token address must not be 0x0\"\n        );\n\n        bridge = _bridge;\n        bridgeToken = _bridgeToken;\n        tbtc = _tbtc;\n        mintingLimit = type(uint256).max;\n    }\n\n    /// @notice This function is called when the user sends their token from L2.\n    ///         The contract burns the canonical tBTC from the user and sends\n    ///         wormhole tBTC representation over the bridge.\n    ///         Keep in mind that when multiple bridges receive a minting\n    ///         authority on the canonical tBTC, this function may not be able\n    ///         to send all amounts of tBTC through the Wormhole bridge. The\n    ///         capability of Wormhole Bridge to send tBTC from the chain is\n    ///         limited to the amount of tBTC bridged through Wormhole to that\n    ///         chain.\n    /// @dev Requirements:\n    ///      - The sender must have at least `amount` of the canonical tBTC and\n    ///        it has to be approved for L2WormholeGateway.\n    ///      - The L2WormholeGateway must have at least `amount` of the wormhole\n    ///        tBTC.\n    ///      - The recipient must not be 0x0.\n    ///      - The amount to transfer must not be 0,\n    ///      - The amount to transfer must be >= 10^10 (1e18 precision).\n    ///      Depending if Wormhole tBTC gateway is registered on the target\n    ///      chain, this function uses transfer or transfer with payload over\n    ///      the Wormhole bridge.\n    /// @param amount The amount of tBTC to be sent.\n    /// @param recipientChain The Wormhole recipient chain ID.\n    /// @param recipient The address of the recipient in the Wormhole format.\n    /// @param arbiterFee The Wormhole arbiter fee. Ignored if sending\n    ///                   tBTC to chain with Wormhole tBTC gateway.\n    /// @param nonce The Wormhole nonce used to batch messages together.\n    /// @return The Wormhole sequence number.\n    function sendTbtc(\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        uint256 arbiterFee,\n        uint32 nonce\n    ) external payable nonReentrant returns (uint64) {\n        require(recipient != bytes32(0), \"0x0 recipient not allowed\");\n        require(amount != 0, \"Amount must not be 0\");\n\n        // Normalize the amount to bridge. The dust can not be bridged due to\n        // the decimal shift in the Wormhole Bridge contract.\n        amount = WormholeUtils.normalize(amount);\n\n        // Check again after dropping the dust.\n        require(amount != 0, \"Amount too low to bridge\");\n\n        require(\n            bridgeToken.balanceOf(address(this)) >= amount,\n            \"Not enough wormhole tBTC in the gateway to bridge\"\n        );\n\n        bytes32 gateway = gateways[recipientChain];\n\n        emit WormholeTbtcSent(\n            amount,\n            recipientChain,\n            gateway,\n            recipient,\n            arbiterFee,\n            nonce\n        );\n\n        mintedAmount -= amount;\n        tbtc.burnFrom(msg.sender, amount);\n        bridgeToken.safeApprove(address(bridge), amount);\n\n        if (gateway == bytes32(0)) {\n            // No Wormhole tBTC gateway on the target chain. The token minted\n            // by Wormhole should be considered canonical.\n            return\n                bridge.transferTokens{value: msg.value}(\n                    address(bridgeToken),\n                    amount,\n                    recipientChain,\n                    recipient,\n                    arbiterFee,\n                    nonce\n                );\n        } else {\n            // There is a Wormhole tBTC gateway on the target chain.\n            // The gateway needs to mint canonical tBTC for the recipient\n            // encoded in the payload.\n            return\n                bridge.transferTokensWithPayload{value: msg.value}(\n                    address(bridgeToken),\n                    amount,\n                    recipientChain,\n                    gateway,\n                    nonce,\n                    abi.encode(recipient)\n                );\n        }\n    }\n\n    /// @notice This function is called when the user redeems their token on L2.\n    ///         The contract receives Wormhole tBTC representation and mints the\n    ///         canonical tBTC for the user.\n    ///         If the tBTC minting limit has been reached by this contract,\n    ///         instead of minting tBTC the receiver address receives Wormhole\n    ///         tBTC representation.\n    /// @dev Requirements:\n    ///      - The receiver of Wormhole tBTC should be the L2WormholeGateway\n    ///        contract.\n    ///      - The receiver of the canonical tBTC should be abi-encoded in the\n    ///        payload.\n    ///      - The receiver of the canonical tBTC must not be the zero address.\n    ///\n    ///      The Wormhole Token Bridge contract has protection against redeeming\n    ///      the same VAA again. When a Token Bridge VAA is redeemed, its\n    ///      message body hash is stored in a map. This map is used to check\n    ///      whether the hash has already been set in this map. For this reason,\n    ///      this function does not have to be nonReentrant in theory. However,\n    ///      to make this function non-dependent on Wormhole Bridge implementation,\n    ///      we are making it nonReentrant anyway.\n    /// @param encodedVm A byte array containing a Wormhole VAA signed by the\n    ///        guardians.\n    function receiveTbtc(bytes calldata encodedVm) external nonReentrant {\n        // ITokenBridge.completeTransferWithPayload completes a contract-controlled\n        // transfer of an ERC20 token. Calling this function is not enough to\n        // ensure L2WormholeGateway received Wormhole tBTC representation.\n        // Instead of going too deep into the ITokenBridge implementation,\n        // asserting who is the receiver of the token, and which token it is,\n        // we check the balance before the ITokenBridge call and the balance\n        // after ITokenBridge call. This way, we are sure this contract received\n        // Wormhole tBTC token in the given amount. This is transparent to\n        // all potential upgrades of ITokenBridge implementation and no other\n        // validations are needed.\n        uint256 balanceBefore = bridgeToken.balanceOf(address(this));\n        bytes memory encoded = bridge.completeTransferWithPayload(encodedVm);\n        uint256 balanceAfter = bridgeToken.balanceOf(address(this));\n\n        uint256 amount = balanceAfter - balanceBefore;\n        // Protect against the custody of irrelevant tokens.\n        require(amount > 0, \"No tBTC transferred\");\n\n        address receiver = fromWormholeAddress(\n            bytes32(bridge.parseTransferWithPayload(encoded).payload)\n        );\n        require(receiver != address(0), \"0x0 receiver not allowed\");\n\n        // We send wormhole tBTC OR mint canonical tBTC. We do not want to send\n        // dust. Sending wormhole tBTC is an exceptional situation and we want\n        // to keep it simple.\n        if (mintedAmount + amount > mintingLimit) {\n            bridgeToken.safeTransfer(receiver, amount);\n        } else {\n            // The function is non-reentrant.\n            // slither-disable-next-line reentrancy-benign\n            mintedAmount += amount;\n            tbtc.mint(receiver, amount);\n        }\n\n        // The function is non-reentrant.\n        // slither-disable-next-line reentrancy-events\n        emit WormholeTbtcReceived(receiver, amount);\n    }\n\n    /// @notice Lets the governance to update the tBTC gateway address on the\n    ///         chain with the given Wormhole ID.\n    /// @dev Use toWormholeAddress function to convert between Ethereum and\n    ///      Wormhole address formats.\n    /// @param chainId Wormhole ID of the chain.\n    /// @param gateway Address of tBTC gateway on the given chain in a Wormhole\n    ///                format.\n    function updateGatewayAddress(uint16 chainId, bytes32 gateway)\n        external\n        onlyOwner\n    {\n        gateways[chainId] = gateway;\n        emit GatewayAddressUpdated(chainId, gateway);\n    }\n\n    /// @notice Lets the governance to update the tBTC minting limit for this\n    ///         contract.\n    /// @param _mintingLimit The new minting limit.\n    function updateMintingLimit(uint256 _mintingLimit) external onlyOwner {\n        mintingLimit = _mintingLimit;\n        emit MintingLimitUpdated(_mintingLimit);\n    }\n\n    /// @notice Converts Ethereum address into Wormhole format.\n    /// @param _address The address to convert.\n    function toWormholeAddress(address _address)\n        external\n        pure\n        returns (bytes32)\n    {\n        return WormholeUtils.toWormholeAddress(_address);\n    }\n\n    /// @notice Converts Wormhole address into Ethereum format.\n    /// @param _address The address to convert.\n    function fromWormholeAddress(bytes32 _address)\n        public\n        pure\n        returns (address)\n    {\n        return WormholeUtils.fromWormholeAddress(_address);\n    }\n}\n"
    },
    "@keep-network/tbtc-v2/contracts/l2/Wormhole.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity ^0.8.17;\n\n/// @title WormholeTypes\n/// @notice Namespace which groups all types relevant to Wormhole interfaces.\nlibrary WormholeTypes {\n    /// @dev See: https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/2b7db51f99b49eda99b44f4a044e751cb0b2e8ea/src/interfaces/IWormholeRelayer.sol#L22\n    struct VaaKey {\n        uint16 chainId;\n        bytes32 emitterAddress;\n        uint64 sequence;\n    }\n}\n\n/// @title IWormhole\n/// @notice Wormhole interface.\n/// @dev See: https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/2b7db51f99b49eda99b44f4a044e751cb0b2e8ea/src/interfaces/IWormhole.sol#L6\ninterface IWormhole {\n    /// @dev See: https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/2b7db51f99b49eda99b44f4a044e751cb0b2e8ea/src/interfaces/IWormhole.sol#L109\n    function chainId() external view returns (uint16);\n\n    /// @dev See: https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/2b7db51f99b49eda99b44f4a044e751cb0b2e8ea/src/interfaces/IWormhole.sol#L117\n    function messageFee() external view returns (uint256);\n}\n\n/// @title IWormholeRelayer\n/// @notice Wormhole Relayer interface.\n/// @dev See: https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/2b7db51f99b49eda99b44f4a044e751cb0b2e8ea/src/interfaces/IWormholeRelayer.sol#L74\ninterface IWormholeRelayer {\n    /// @dev See: https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/2b7db51f99b49eda99b44f4a044e751cb0b2e8ea/src/interfaces/IWormholeRelayer.sol#L442\n    function quoteEVMDeliveryPrice(\n        uint16 targetChain,\n        uint256 receiverValue,\n        uint256 gasLimit\n    )\n        external\n        view\n        returns (\n            uint256 nativePriceQuote,\n            uint256 targetChainRefundPerGasUnused\n        );\n\n    /// @dev See: https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/2b7db51f99b49eda99b44f4a044e751cb0b2e8ea/src/interfaces/IWormholeRelayer.sol#L182\n    function sendVaasToEvm(\n        uint16 targetChain,\n        address targetAddress,\n        bytes memory payload,\n        uint256 receiverValue,\n        uint256 gasLimit,\n        WormholeTypes.VaaKey[] memory vaaKeys,\n        uint16 refundChain,\n        address refundAddress\n    ) external payable returns (uint64 sequence);\n}\n\n/// @title IWormholeReceiver\n/// @notice Wormhole Receiver interface.\n/// @dev See: https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/2b7db51f99b49eda99b44f4a044e751cb0b2e8ea/src/interfaces/IWormholeReceiver.sol#L8\ninterface IWormholeReceiver {\n    /// @dev See: https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/2b7db51f99b49eda99b44f4a044e751cb0b2e8ea/src/interfaces/IWormholeReceiver.sol#L44\n    function receiveWormholeMessages(\n        bytes memory payload,\n        bytes[] memory additionalVaas,\n        bytes32 sourceAddress,\n        uint16 sourceChain,\n        bytes32 deliveryHash\n    ) external payable;\n}\n\n/// @title IWormholeTokenBridge\n/// @notice Wormhole Token Bridge interface.\n/// @dev See: https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/2b7db51f99b49eda99b44f4a044e751cb0b2e8ea/src/interfaces/ITokenBridge.sol#L9\ninterface IWormholeTokenBridge {\n    function completeTransferWithPayload(bytes memory encodedVm)\n        external\n        returns (bytes memory);\n\n    function parseTransferWithPayload(bytes memory encoded)\n        external\n        pure\n        returns (TransferWithPayload memory transfer);\n\n    function transferTokens(\n        address token,\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        uint256 arbiterFee,\n        uint32 nonce\n    ) external payable returns (uint64 sequence);\n\n    function transferTokensWithPayload(\n        address token,\n        uint256 amount,\n        uint16 recipientChain,\n        bytes32 recipient,\n        uint32 nonce,\n        bytes memory payload\n    ) external payable returns (uint64 sequence);\n\n    struct TransferWithPayload {\n        uint8 payloadID;\n        uint256 amount;\n        bytes32 tokenAddress;\n        uint16 tokenChain;\n        bytes32 to;\n        uint16 toChain;\n        bytes32 fromAddress;\n        bytes payload;\n    }\n}\n\n/// @title WormholeUtils\n/// @notice Library for Wormhole utilities.\nlibrary WormholeUtils {\n    /// @notice Converts Ethereum address into Wormhole format.\n    /// @param _address The address to convert.\n    function toWormholeAddress(address _address)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return bytes32(uint256(uint160(_address)));\n    }\n\n    /// @notice Converts Wormhole address into Ethereum format.\n    /// @param _address The address to convert.\n    function fromWormholeAddress(bytes32 _address)\n        internal\n        pure\n        returns (address)\n    {\n        return address(uint160(uint256(_address)));\n    }\n\n    /// @dev Eliminates the dust that cannot be bridged with Wormhole\n    ///      due to the decimal shift in the Wormhole Bridge contract.\n    ///      See https://github.com/wormhole-foundation/wormhole/blob/96682bdbeb7c87bfa110eade0554b3d8cbf788d2/ethereum/contracts/bridge/Bridge.sol#L276-L288\n    function normalize(uint256 amount) internal pure returns (uint256) {\n        // slither-disable-next-line divide-before-multiply\n        amount /= 10**10;\n        amount *= 10**10;\n        return amount;\n    }\n}\n"
    },
    "@keep-network/tbtc-v2/contracts/Timelock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/governance/TimelockController.sol\";\n\ncontract Timelock is TimelockController {\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) TimelockController(minDelay, proposers, executors, address(0)) {}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/cryptography/EIP712Upgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../token/ERC721/IERC721Receiver.sol\";\nimport \"../token/ERC1155/IERC1155Receiver.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl, IERC721Receiver, IERC1155Receiver {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with the following parameters:\n     *\n     * - `minDelay`: initial minimum delay for operations\n     * - `proposers`: accounts to be granted proposer and canceller roles\n     * - `executors`: accounts to be granted executor role\n     * - `admin`: optional account to be granted admin role; disable with zero address\n     *\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\n     * without being subject to delay, but this role should be subsequently renounced in favor of\n     * administration through timelocked proposals. Previous versions of this contract would assign\n     * this admin to the deployer automatically and should be renounced as well.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors,\n        address admin\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _setupRole(TIMELOCK_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n            _setupRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, AccessControl) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool registered) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) internal virtual {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/test/BaseL1BitcoinDepositorUpgraded.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@keep-network/tbtc-v2/contracts/l2/L1BitcoinDepositor.sol\";\r\n\r\n/// @notice L1BitcoinDepositor for Base - upgraded version.\r\n/// @dev This contract is intended solely for testing purposes.\r\ncontract BaseL1BitcoinDepositorUpgraded is L1BitcoinDepositor {\r\n    string public newVar;\r\n\r\n    function initializeV2(string memory _newVar) public {\r\n        newVar = _newVar;\r\n    }\r\n}"
    },
    "contracts/test/BaseL2BitcoinDepositorUpgraded.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@keep-network/tbtc-v2/contracts/l2/L2BitcoinDepositor.sol\";\r\n\r\n/// @notice L2BitcoinDepositor for Base - upgraded version.\r\n/// @dev This contract is intended solely for testing purposes.\r\ncontract BaseL2BitcoinDepositorUpgraded is L2BitcoinDepositor {\r\n    string public newVar;\r\n\r\n    function initializeV2(string memory _newVar) public {\r\n        newVar = _newVar;\r\n    }\r\n}"
    },
    "contracts/test/BaseTBTCUpgraded.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@keep-network/tbtc-v2/contracts/l2/L2TBTC.sol\";\r\n\r\n/// @notice Canonical tBTC Token on Base - upgraded version.\r\n/// @dev This contract is intended solely for testing purposes. As it currently\r\n///      stands in the implementation of L2TBTC.sol, there are no reserved\r\n///      storage gap slots available, thereby limiting the upgradability to a\r\n///      child contract only.\r\ncontract BaseTBTCUpgraded is L2TBTC {\r\n    string public newVar;\r\n\r\n    function initializeV2(string memory _newVar) public {\r\n        newVar = _newVar;\r\n    }\r\n}\r\n"
    },
    "contracts/test/BaseWormholeGatewayUpgraded.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@keep-network/tbtc-v2/contracts/l2/L2WormholeGateway.sol\";\r\n\r\n/// @notice Wormhole gateway for L2 Base - upgraded version.\r\n/// @dev This contract is intended solely for testing purposes. As it currently\r\n///      stands in the implementation of L2WormholeGateway.sol, there are no\r\n///      reserved storage gap slots available, thereby limiting the upgradability\r\n///      to a child contract only.\r\ncontract BaseWormholeGatewayUpgraded is L2WormholeGateway {\r\n    string public newVar;\r\n\r\n    function initializeV2(string memory _newVar) public {\r\n        newVar = _newVar;\r\n    }\r\n}\r\n"
    },
    "contracts/test/TimelockDeployed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.8.17;\r\n\r\nimport \"@keep-network/tbtc-v2/contracts/Timelock.sol\";\r\n\r\n/// @notice Timelock contract for the Keep Network TBTc V2.\r\n/// @dev This contract is intended solely for testing purposes.\r\ncontract TimelockDeployed is Timelock {\r\n    constructor(\r\n        uint256 minDelay,\r\n        address[] memory proposers,\r\n        address[] memory executors\r\n    ) Timelock(minDelay, proposers, executors) {}\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}