:toc: macro

= RFC 1: tBTCv2 Design

:icons: font
:numbered:
toc::[]

== Overview

=== Depositing

Stakers periodically create <<group-size,51-of-100>> ecdsa-backed wallets
to hold frozen BTC assets to maintain account balances. Depositors send BTC
funds to the most-recently-created-wallet by using pay-to-script-hash (P2SH)
which contains hashed information about the depositor's minting ethereum
address. Once the block is mined, the depositor reveals their desired ethereum
minting address to the ethereum chain. The bridge listens for these sorts
of messages and when it gets one, it checks the bitcoin network to make sure
the funds line up. If everything checks out, then we update your ethereum-side
account balance.

=== Redemption

A user with an account balance supplies a bitcoin address. The system decreases
their account balance releases the equivalent amount of bitcoin to the user
from a user-supplied bitcoin wallet.

In the default case, the user-supplied wallet will be determined by the dApp,
and will be the oldest wallet that is large enough to fulfill the redemption.

The maximum redemption size is capped by the size of the largest wallet, and
any redemption bigger than that will need to be split into multiple
redemptions.

[[continuous-fees]]
=== Continuous Fees

The system is able to collect fees in the form of tBTC when the BTC is
deposited and when it is redeemed. Rather than paying operators at those two
instances we would prefer to pay them continuously. Since we do not have the
tBTC to pay them with until we collect the redemption fee (and can't mint it
and maintain the peg), we must turn to another token. Instead, the system pays
operators in T tokens from a treasury funded by the T-token DAO and whenever it
collects tBTC fees it uses those fees to buy T tokens back for its treasury.

=== Minting And Unminting

A user with an account balance can drain their account balance to mint TBTC.
Similarly, a user can burn TBTC to refill their account balance.

// FIXME: fill in this section with how much TBTC they can mint with regards to
// their unswept balance

== In Depth

[[group-size]]
=== Group Size
There are three main governable parameters that we need to choose:
* The number of signers required to sign messages `threshold`
* The number of group members required for a <<heartbeat,heartbeat>> to be considered "strong". `heartbeat`
* The minimum number of members we're allowed to drop down to during the DKG
  group formation re-try period. `dkg`
* The total size of the group `groupSize`

`threshold < heartbeat < dkg < groupSize`

The total gas cost for sortiton increases linearly with group size by at least
20k gas per member. Requiring more signers to sign messages makes it harder for
adversaries to take over the group, but makes it so that the pool is less
resilient to undelegation or operators going offline. Raising the
strong-heartbeat threshold decreases the chance that you'll not have enough
signers to sign transactions, but decreases a wallets lifespan and increases
overhead. Loweringing the dkg threshold increases the chance that we're able to
create a wallet successfully but gives us a wallet with potentially fewer
operators and a lower lifespan.

Also important is optics - even though a group size of 70 with 40 signers
required to sign messages might have all of the same security properties as a
group size of 100 with 51 signers required to sign messages, it might not
_feel_ as secure. That perception may cause a decreased willingness to invest
capital in the system leading to less money going over the bridge, even though
the fees are less overall.

Since we don't have any workable data that allows us to reasonably estimate
costs (especially with regard to optics), I suggest we start the system out
at decent https://en.wikipedia.org/wiki/Focal_point_(game_theory)[schelling
point] of `groupSize = 100`, `threshold = 51`, `heartbeat = 70`, `dkg = 90` and then let
governance adjust from there once we've gathered data from the system being used.

See link:rfc-2.adoc[RFC 2: tBTCv2 Group Selection and Key Generation] for a deeper dive here

=== Account Balances

The bridge is able to maintain a clean separation of concerns as well as provide the backbone
an extensible financial system rooted in bitcoin-on-ethereum by concerning itself _just_ with
how much bitcoin has gone over the bridge. We keep track of account balances like:
```
contract Balances {
  mapping(address => uint256) private unsweptBalances;
  mapping(address => uint256) private balances;
}
```

When bitcoin enters the system, the associated account's unsweptBalance
increases. When that deposit is swept, that amount is tranfered to the balance.
_If_ a user decides to mint a TBTC bitcoin from their balance, their balance
would be drained and a TBTC token would be minted. When a user brings back TBTC
to the system, the token is burned and the account balance increases. If the
user wants BTC, they can drain their account balance to redeem it.

This more abstract design lets us not only do things like mint TBTC by draining
account balances, but also move into other financial concepts like
bitcoin-collateralized loans or bitcoin-backed stablecoins.

Neither of the above concepts are in-scope for this RFC, but the important part
is that we want to make sure we're starting with the more flexible
account-balances design so that we're not stuck later.

=== Depositing

==== Deposit + Commitment

Once we know the active wallet's public key hash, the dApp can put together a
pay-to-script-hash (P2SH) address to receive the funds. This script will be
unique to each depositor and will look like:

```
<eth-address> DROP
<blinding-factor> DROP
DUP HASH160 <signingGroupPubkey> EQUAL
IF
  CHECKSIG
ELSE
  DUP HASH160 <refundPubkey> EQUALVERIFY
  <locktime> CHECKLOCKTIMEVERIFY DROP
  CHECKSIG
ENDIF
```

Since each depositor has their own ethereum address and their own secret
blinding factor (which is an additional security layer), each depositor's
script will be unique, and the hash of each depositor's script will be unique.

In order to unlock the funds, one must provide the unhashed script, (which
means that they know the eth address and blinding factor), as well as an
unlocking script with a signature and public key. If the sig+pubkey matches the
signing group public key, the funds are able to be moved immediately. If the
sig+pubkey matches the refund public key, then the funds can be moved after 30
days (specified as `locktime`).

==== The Big Reveal

After the deposit transaction has been mined, the user is able to reveal their
ethereum address and blinding factor to the ethereum chain. The bridge listens
for these sorts of messages and when it sees one, is able to generate a script that
can spend the funds. Once successful, we increase the account's unswept balance.

Second, we schedule an operation that batces all outstanding known-refundable
transactions together to be combined with the existing wallet output into a
single output. The frequency of this operation is a governable parameter. When
this sweep occurs, we decrease the relevant account's unswept balances and
increase their balances. This disables any outstanding 30-day refunds.

==== Automated Refunds

A bitcoin transaction is an amount and a script. The script can be something as
simple as "these funds can be spent by wallet 0xabc", or in our case, as
complex as "these funds can be spent by wallet 0xabc but if they aren't spent
within 30 days they can be spent by wallet 0x123". This gives us the ability to
create deposits that automatically are refunded after 30 days if they aren't
swept. Thus, if a user misfunds or they get cold feet (for any reason), all
they need to do is not submit their reveal and wait 30 days.

=== Redemption

To initiate a redemption, a user with a balance > `x` supplies a bitcoin
address. Then, the system calculates the redemption fee `fee`, and releases an
amount of bitcoin `y` such that `x = y + fee` to the supplied bitcoin address.
The remaining `fee` sold by the system to buy back `T` tokens (more about this
process in the <<continuous-fees,fee section>>) to pay to the operators.

In the MVP version of the system, a redemption is capped at the amount of
bitcoin contained in the largest wallet. The wallet doing the redemption is
selected by the redeemer, but the dApp should suggest that this is the oldest
wallet that contains enough bitcoin to fulfil the redemption. If more BTC
needs to be redeemed than there is in the largest wallet, then the user needs
to submit multiple redemptions. After a redemption, if a wallet has under a
governable threshhold of BTC remaining, it transfers that BTC to the active
wallet and closes.

=== Wallet Lifecycle

Wallets are periodically created, where the period length is a governable
parameter. To create a new wallet, a group of 100 operators is selected from
the pool of available operators (some operators may be selected twice if there
are not enough) using a process called sortition. The probabiliy that a
particular operator is chosen is based on their stake weight, which in turn is
based on the number of `T` tokens they have invested in the staking contract.

Once the operators have been selected from the sortition pool, they generate a
51-of-100 ecdsa signing group to handle the bitcoin key material per the
process described in link:rfc-2.adoc[RFC 2: tBTCv2 Group Selection and Key
Generation]. The group size may end up being smaller depending on retries.

As time passes and operators drop out of the system, a wallet becomes at risk
of being able to meet the 51-of-100 threshhold to produce signatures.
Additionally, we want to avoid situations where operators are the custodians of
a wallet for extended periods. To avoid these issues, we can set a max age of a
wallet and a heartbeat threshold. Once a wallet is older than the max age, or
if it drops below the liveness threshhold (say, below 70 on a
<<heartbeat,heartbeat>>), we motion to transfer the funds to another randomly
selected wallet.

Once a wallet no longer has funds and is not the primary wallet for new
deposits, it can be closed and operators are no longer required to maintain
it.

[[heartbeat]]
=== Heartbeats

To make sure that older wallets are still accessible for redemption, we need to
perform heartbeats. The signing group signs each bitcoin block and then does _not_
publish the result. If a signer suspects other signers are not online, they can
issue an on-chain challenge to publish a specified signed bitcoin block (with a
maximum block age). Since publishing this information costs the signers gas, the
challenger must pay a deposit to be distributed to the signers if they pass.

Any signer unable to publish the signed block within a specified amount of time
will begin to be slashed and the challenger will be rewarded.
