:toc: macro

= RFC 8: Cross-chain Tokenized Threshold BTC

:icons: font
:numbered:
toc::[]

== Goal

The goal of this proposal is to enable *efficient* cross-chain tBTC liquidity.

In the Ethereum ecosystem, that means bringing Bitcoin to L2s and sidechains like
Arbitrum, Optimism, Polygon, Avalanche, and Binance Smart Chain. In the Cosmos
ecosystem, that means Bitcoin on IBC-enabled zones (chains) like Osmosis and
Penumbra. And in newer ecosystems, that means chains like Solana, Aptos, and
Sui.

Efficiency requires minimizing liquidity fragmentation by avoiding the need for
tBTC wrapper tokens by each chain and bridge. This situation quickly leads to an
`n*m` problem, where liquidity on `n` chains is divided between `m`
bridges. Each of these token variants soaks up valuable liquidity that could be
better utilized elsehwere.

Because tBTC is minted "centrally" on Ethereum L1, we can do better. By
deploying a canonical token on each chain, we can ensure the supply of tBTC
remains sacrosanct, while enabling quick, interoperable cross-chain bridges and
localizing ecosystem risk.

== Overview

To achieve this goal, I propose we deploy a canonical tBTC contract on each
chain we support. This contract should be flexible enough to:

* Delegate restricted minting authority to a native bridge on the chain, if
  present.
* Delegate restricted minting authority to a short list of ecosystem bridges
* Be paused by any one of `n` guardians, allowing avoidance of contagion in case
  of a chain- or bridge-specific incident.
* Be governed by the Threshold Council until we can land on a longer-term
  cross-chain governance mechanism.

== Initial implementation

The goal of the initial implementation is to bring Bitcoin to the following L2s
and sidechains:

* Arbitrum,
* Polygon,
* Optimism.

The cross-bridge architecture and patterns we are going to choose should allow
us to scale to other L2s, sidechains, and chains quickly.

=== Canonical token

The canonical token we are going to deploy will be different from the L1 token
deployed at `0x18084fbA666a33d37592fA2633fD49a74DD93a88`. The L2/sidechain token
will be upgradeable, owned by Threshold Council, will delegate the minting
authority to multiple parties, and have a pause functionality for mints and
burns.

Given those requirements, the address of the canonical TBTC token on L2s and
sidechains will be different from the one deployed on L1.

A generic implementation of the token will be provided in the `solidity` smart
contracts directory.

=== Minting on L1

Rather than change our L1 implementation to be aware of L2s and sidechains,
we'll start as simply as possible. Every tBTC mint will continue to require
transactions on Ethereum from the user — first a deposit reveal, then a lock
to bridge to another network.

=== Supporting native bridges

A number of relevant chains include "native" bridges — canonical bridges for the
chain that require interoperability. These bridges are both the most important
and the trickiest to support.

Each native bridge has its own way mechanism to manage an Ethereum-to-chain
token contract mapping, sometimes called a token registry.

Examples of chains with native bridges include:

* Arbitrum,
* Polygon,
* Optimism.

=== Supporting cross-ecosystem bridges

TODO 

=== Multisig governance


The Governance in the initial implementation should be based on Gnosis Safe
6-of-9 Threshold Council Multisig. Since the Gnosis Safe for Threshold Council
was deployed using Safe Proxy factory v1.3.0, it
link:https://help.safe.global/en/articles/5267779-i-sent-assets-to-a-safe-address-on-the-wrong-network-any-chance-to-recover[should be possible]
to replay the same transaction creating Gnosis Safe with the same address on the
supported L2s and sidechains.

The Governance will be able to add and remove minters to L2/sidechain TBTC
canonical contract.


=== Code organization

The code that exists in the `solidity` directory should contain components
specific to L1 and generic L2 components that will be reused between EVM
L2 and sidechain implementations. The code specific to individual chains should
be placed in a chain-specific directory, in a separate NPM project:
`cross-chain/{$chainName}`.

For example:

* `cross-chain/arbitrum`,
* `cross-chain/polygon`,
* `cross-chain/optimism`.

Each `cross-chain` project should contain L1 and L2
contracts specific to that individual subchain. This separation will allow us to
abstract out the complexity of deployment and avoid redeploying all L1 testnet
contracts in case a single change in one of L2 contracts is needed.

This organization of the code will also allow us to not add subchain-specific
dependencies to the L1 project and to deploy NPM packages separately:

* `@keep-network/tbtc-v2-arbitrum`,
* `@keep-network/tbtc-v2-polygon`,
* `@keep-network/tbtc-v2-optimism`.

Every chain requires its own network and compiler configuration.
The `@keep-network/tbtc-v2` package is quite heavy and there is no
straightforward way to distinguish on which chain the given contract was
deployed if we do not separate NPM packages.

Each project should have its own CI process that may incorporate jobs specific
to that chain if needed. 

The CI processes of `cross-chain` projects should include Goerli deployment
jobs. Note that the separation of the code does not mean the deployment is fully
separated between chains. Both L1 and L2 contracts need to be deployed from the
given `cross-chain` module. L1 contracts may require addresses of contracts from
L2 and L2 contract addresses may require addresses of contracts from L1.

```
├── solidity
│   ├── (...)
│   └── l2
│       └── L2TBTC.sol
└── cross-chain
    ├── arbitrum
    │   ├── package.json
    │   └── solidity
    │      ├── ArbitrumL1Gateway.sol 
    │      ├── ArbitrumL2Gateway.sol 
    │      └── ArbitrumTBTC.sol 
    ├── optimism
    │   ├── package.json
    │   └── solidity
    │      ├── OptimismL1Gateway.sol 
    │      ├── OptimismL2Gateway.sol 
    │      └── OptimismTBTC.sol 
    └── polygon
        ├── package.json
        └── solidity
           ├── PolygonL1Gateway.sol 
           ├── PolygonL2Gateway.sol 
           └── PolygonTBTC.sol 
```

`L2TBTC.sol` is an abstract contract doing all the heavy lifting: upgradeability,
authorization of minters, and minting pause. This generic contract is inherited
by L2-specific tokens: `ArbitrumTBTC`, `OptimismTBTC`, and `PolygonTBTC`.

Each `cross-chain` module has its own `package.json` so it's an independent
project with a separate NPM package deployment job and CI jobs.

Both L1 and L2 contracts specific to the given chain are placed next to each
other. For example, `ArbitrumL1Gateway` deployed on L1 Ethereum, and
`ArbitrumL2Gateway` deployed on L2 Arbitrum. It means the deployment job of the
given `cross-chain` module must be able to work both with L1 and L2 and to wire
up contracts together.

== Future work
=== Minting on L2
=== Replacing multi-sig governance
