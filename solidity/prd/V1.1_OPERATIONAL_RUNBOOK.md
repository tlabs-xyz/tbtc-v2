# V1.1 Watchdog Operations - Runbook

**Version**: 1.0 | **Date**: 2025-07-15 | **Purpose**: Step-by-step operational procedures

---

## 📖 Table of Contents

1. [Daily Operations](#daily-operations)
2. [Reserve Attestation](#reserve-attestation)
3. [Wallet Registration](#wallet-registration)
4. [Challenge Response](#challenge-response)
5. [Dispute Resolution](#dispute-resolution)
6. [Emergency Response](#emergency-response)
7. [System Maintenance](#system-maintenance)

---

## 1. Daily Operations

### 1.1 Morning Checklist (09:00 UTC)

**Step 1: System Health Check**
```bash
# Check system status
npx hardhat console --network mainnet
> const consensus = await ethers.getContract("OptimisticWatchdogConsensus")
> const state = await consensus.getConsensusState()
> console.log("Active watchdogs:", state.activeWatchdogs)
> console.log("Emergency pause:", state.emergencyPause)
```

**Step 2: Watchdog Status**
```bash
# Verify your watchdog is active
> const myAddress = "0x..." // Your watchdog address
> const isActive = await consensus.isActiveWatchdog(myAddress)
> console.log("My watchdog active:", isActive)
```

**Step 3: Pending Operations**
```bash
# Check for pending operations requiring attention
> const adapter = await ethers.getContract("WatchdogAdapter")
> const stats = await adapter.getWatchdogStats(myAddress)
> console.log("Last attestation:", stats[0])
> console.log("Attestation count:", stats[1])
```

**Step 4: Recent Events**
```bash
# Query recent events (last 24 hours)
const filter = consensus.filters.OperationChallenged()
const events = await consensus.queryFilter(filter, -6400) // ~24h blocks
console.log("Recent challenges:", events.length)
```

**✅ Daily Health Check Complete**

### 1.2 Evening Review (21:00 UTC)

**Step 1: Daily Statistics**
- Operations submitted: ___
- Challenges raised: ___
- Escalations: ___
- Successful executions: ___

**Step 2: Performance Metrics**
- Average consensus time: ___
- Challenge resolution time: ___
- System availability: ___

**Step 3: Action Items**
- [ ] Review any unusual patterns
- [ ] Update monitoring dashboards
- [ ] Prepare for next day operations

---

## 2. Reserve Attestation

### 2.1 Routine Reserve Attestation

**Trigger**: QC balance change detected or scheduled attestation

**Step 1: Verify QC Status**
```bash
# Check QC is active and in good standing
> const qcManager = await ethers.getContract("QCManager")
> const qcData = await qcManager.getQCData(qcAddress)
> console.log("QC Status:", qcData.status) // Should be Active
```

**Step 2: Calculate Current Balance**
```bash
# Get current Bitcoin balance from monitoring system
const bitcoinBalance = await bitcoinMonitor.getBalance(qcAddress)
const balanceWei = ethers.utils.parseEther(bitcoinBalance.toString())
```

**Step 3: Validate Balance Requirements**
```bash
# Check balance covers minted amounts
> const currentMinted = qcData.currentMinted
> const requiredReserves = currentMinted // 1:1 backing
> console.log("Required reserves:", ethers.utils.formatEther(requiredReserves))
> console.log("Actual balance:", ethers.utils.formatEther(balanceWei))
```

**Step 4: Submit Attestation**
```bash
# Submit via WatchdogAdapter
> const adapter = await ethers.getContract("WatchdogAdapter")
> const tx = await adapter.attestReserves(qcAddress, balanceWei)
> console.log("Attestation submitted:", tx.hash)
```

**Step 5: Monitor Execution**
```bash
# Check if you're the primary validator
> const operationData = ethers.utils.defaultAbiCoder.encode(
    ["address", "uint256"],
    [qcAddress, balanceWei]
  )
> const primaryValidator = await consensus.calculatePrimaryValidator(
    consensus.RESERVE_ATTESTATION(),
    operationData
  )
> console.log("Primary validator:", primaryValidator)
> console.log("Is me:", primaryValidator.toLowerCase() === myAddress.toLowerCase())
```

**✅ Reserve Attestation Complete**

### 2.2 Emergency Reserve Attestation

**Trigger**: Urgent balance update needed (undercollateralization detected)

**Step 1: Immediate Assessment**
```bash
# Verify emergency conditions
> const currentBalance = await bitcoinMonitor.getBalance(qcAddress)
> const mintedAmount = await qcManager.getCurrentMinted(qcAddress)
> const collateralRatio = currentBalance / mintedAmount
> console.log("Collateral ratio:", collateralRatio)
```

**Step 2: Emergency Submission**
```bash
# Submit with high priority
> const tx = await adapter.attestReserves(qcAddress, balanceWei, {
    gasPrice: ethers.utils.parseUnits("50", "gwei") // High gas price
  })
> console.log("Emergency attestation:", tx.hash)
```

**Step 3: Notify Team**
```
Send alert to #tbtc-watchdog-ops:
🚨 EMERGENCY ATTESTATION SUBMITTED
QC: ${qcAddress}
Ratio: ${collateralRatio}
Tx: ${tx.hash}
Status: Monitoring
```

**✅ Emergency Attestation Complete**

---

## 3. Wallet Registration

### 3.1 New Wallet Registration

**Trigger**: QC requests new Bitcoin wallet registration

**Step 1: Receive Registration Request**
```bash
# QC submits request off-chain with:
# - Bitcoin address
# - Proof of control intent
# - Supporting documentation
```

**Step 2: Generate Challenge Hash**
```bash
# Create unique challenge for this registration
> const challenge = ethers.utils.keccak256(
    ethers.utils.defaultAbiCoder.encode(
      ["address", "string", "uint256"],
      [qcAddress, btcAddress, block.timestamp]
    )
  )
> console.log("Challenge hash:", challenge)
```

**Step 3: Request Control Proof**
```
Provide challenge hash to QC:
"Please create a Bitcoin transaction from ${btcAddress} 
with OP_RETURN containing ${challenge}"
```

**Step 4: Verify SPV Proof**
```bash
# QC provides SPV proof of control transaction
> const spvValidator = await ethers.getContract("SPVValidator")
> const isValid = await spvValidator.verifyWalletControl(
    qcAddress,
    btcAddress,
    challenge,
    txInfo,
    proof
  )
> console.log("SPV proof valid:", isValid)
```

**Step 5: Submit Registration**
```bash
# Submit registration operation
> const tx = await adapter.registerWalletWithProof(
    qcAddress,
    btcAddress,
    spvProof,
    challenge
  )
> console.log("Registration submitted:", tx.hash)
```

**✅ Wallet Registration Complete**

---

## 4. Challenge Response

### 4.1 Responding to Operation Challenge

**Trigger**: Another watchdog challenges your operation

**Step 1: Analyze Challenge**
```bash
# Get challenge details
> const challenges = await consensus.getOperationChallenges(operationId)
> console.log("Challenge evidence:", challenges[0].evidence)
> console.log("Challenger:", challenges[0].challenger)
```

**Step 2: Gather Evidence**
```bash
# Collect supporting evidence for your operation
const evidence = {
  bitcoinTxHash: "...",
  blockConfirmations: 6,
  balanceCalculation: "...",
  qcVerification: "..."
}
```

**Step 3: Prepare Response**
```markdown
# Challenge Response Template
**Operation**: ${operationId}
**Challenger**: ${challenger}
**Challenge**: ${challengeReason}

**Response**:
1. Evidence validation: ✅/❌
2. Calculation verification: ✅/❌  
3. Additional proof: [attachment]
4. Recommended action: Approve/Reject
```

**Step 4: Communicate Response**
```
Post in #tbtc-watchdog-ops:
📋 CHALLENGE RESPONSE
Operation: ${operationId}
My Position: [Approve/Reject]
Evidence: [link to detailed analysis]
Next: Waiting for other watchdog reviews
```

**✅ Challenge Response Complete**

### 4.2 Challenging Suspicious Operation

**Trigger**: You detect suspicious or invalid operation

**Step 1: Validate Suspicion**
```bash
# Verify your concerns are valid
> const operation = await consensus.getOperation(operationId)
> const operationData = operation.operationData
> console.log("Operation type:", operation.operationType)
> console.log("Primary validator:", operation.primaryValidator)
```

**Step 2: Gather Evidence**
```bash
# Collect evidence supporting your challenge
const evidence = ethers.utils.formatBytes32String("Invalid balance calculation")
// Or more detailed evidence in bytes format
```

**Step 3: Submit Challenge**
```bash
# Challenge the operation
> const tx = await consensus.challengeOperation(operationId, evidence)
> console.log("Challenge submitted:", tx.hash)
```

**Step 4: Monitor Response**
```bash
# Watch for escalation
> const updatedOperation = await consensus.getOperation(operationId)
> console.log("Objection count:", updatedOperation.objectionCount)
> console.log("New finalize time:", updatedOperation.finalizedAt)
```

**✅ Challenge Submitted**

---

## 5. Dispute Resolution

### 5.1 Approving Disputed Operation

**Trigger**: Operation has ≥3 objections and requires explicit approval

**Step 1: Analyze Dispute**
```bash
# Get all challenges
> const challenges = await consensus.getOperationChallenges(operationId)
> challenges.forEach((challenge, i) => {
    console.log(`Challenge ${i}:`, challenge.evidence)
    console.log(`Challenger:`, challenge.challenger)
  })
```

**Step 2: Independent Verification**
```bash
# Verify operation independently
> const operation = await consensus.getOperation(operationId)
> // Decode operation data based on type
> const decoded = ethers.utils.defaultAbiCoder.decode(
    ["address", "uint256"], // For reserve attestation
    operation.operationData
  )
> console.log("QC:", decoded[0])
> console.log("Balance:", ethers.utils.formatEther(decoded[1]))
```

**Step 3: Make Decision**
```
Decision Matrix:
- Evidence quality: Strong/Weak
- Challenge validity: Valid/Invalid
- Risk assessment: Low/Medium/High
- Recommendation: Approve/Reject
```

**Step 4: Submit Approval (if appropriate)**
```bash
# Only approve if confident operation is valid
> const tx = await consensus.approveOperation(operationId)
> console.log("Approval submitted:", tx.hash)
```

**Step 5: Document Decision**
```
Log decision in #tbtc-watchdog-ops:
✅ OPERATION APPROVED
Operation: ${operationId}
Rationale: [detailed reasoning]
Risk Level: Low
Evidence: [supporting materials]
```

**✅ Dispute Resolution Complete**

---

## 6. Emergency Response

### 6.1 System Pause Procedure

**Trigger**: Critical security issue detected

**Step 1: Assess Threat**
```bash
# Evaluate threat severity
Threat Assessment:
- Scope: System-wide/Localized
- Impact: Critical/High/Medium
- Confidence: High/Medium/Low
- Recommendation: Pause/Monitor/Investigate
```

**Step 2: Initiate Emergency Protocol**
```
Immediate Actions:
1. Alert #tbtc-emergency channel
2. Notify security team
3. Prepare pause justification
4. Coordinate with governance
```

**Step 3: Execute Pause (Governance Only)**
```bash
# Emergency pause (requires EMERGENCY_ROLE)
> const reason = ethers.utils.formatBytes32String("Security issue")
> const tx = await consensus.pause()
> console.log("System paused:", tx.hash)
```

**Step 4: Investigate and Resolve**
```bash
# Analyze issue while system is paused
> const state = await consensus.getConsensusState()
> console.log("Emergency pause active:", state.emergencyPause)
```

**Step 5: Resume Operations**
```bash
# Resume after issue resolution
> const tx = await consensus.unpause()
> console.log("System resumed:", tx.hash)
```

**✅ Emergency Response Complete**

### 6.2 Emergency Override Procedure

**Trigger**: Operation stuck in deadlock or urgent execution needed

**Step 1: Verify Override Necessity**
```bash
# Check operation status
> const operation = await consensus.getOperation(operationId)
> console.log("Objection count:", operation.objectionCount)
> console.log("Approval count:", await consensus.approvalCount(operationId))
> console.log("Can execute:", await consensus.canExecuteOperation(operationId))
```

**Step 2: Prepare Override (Governance Only)**
```bash
# Emergency override with clear justification
> const reason = ethers.utils.formatBytes32String("Deadlock resolution")
> const tx = await consensus.emergencyOverride(operationId, reason)
> console.log("Override executed:", tx.hash)
```

**Step 3: Post-Override Analysis**
```bash
# Analyze what caused the need for override
> const operation = await consensus.getOperation(operationId)
> console.log("Operation executed:", operation.executed)
```

**✅ Emergency Override Complete**

---

## 7. System Maintenance

### 7.1 Adding New Watchdog

**Trigger**: New watchdog approved by governance

**Step 1: Prepare New Watchdog**
```bash
# Verify new watchdog setup
const newWatchdogAddress = "0x..."
# Ensure watchdog has proper infrastructure
# Verify security requirements met
```

**Step 2: Add to Consensus System**
```bash
# Add watchdog (requires MANAGER_ROLE)
> const tx = await consensus.addWatchdog(newWatchdogAddress)
> console.log("Watchdog added:", tx.hash)
```

**Step 3: Grant Operator Role**
```bash
# Grant WATCHDOG_OPERATOR_ROLE in adapter
> const adapter = await ethers.getContract("WatchdogAdapter")
> const OPERATOR_ROLE = ethers.utils.id("WATCHDOG_OPERATOR_ROLE")
> const tx = await adapter.grantRole(OPERATOR_ROLE, newWatchdogAddress)
> console.log("Operator role granted:", tx.hash)
```

**Step 4: Verify Integration**
```bash
# Verify new watchdog is active
> const activeWatchdogs = await consensus.getActiveWatchdogs()
> console.log("Active watchdogs:", activeWatchdogs)
> console.log("Includes new watchdog:", activeWatchdogs.includes(newWatchdogAddress))
```

**✅ Watchdog Addition Complete**

### 7.2 Removing Inactive Watchdog

**Trigger**: Watchdog becomes inactive or compromised

**Step 1: Document Removal Reason**
```bash
# Prepare removal justification
const reason = ethers.utils.formatBytes32String("Inactivity")
const watchdogAddress = "0x..."
```

**Step 2: Remove from Consensus**
```bash
# Remove watchdog (requires MANAGER_ROLE)
> const tx = await consensus.removeWatchdog(watchdogAddress, reason)
> console.log("Watchdog removed:", tx.hash)
```

**Step 3: Revoke Operator Role**
```bash
# Revoke WATCHDOG_OPERATOR_ROLE
> const OPERATOR_ROLE = ethers.utils.id("WATCHDOG_OPERATOR_ROLE")
> const tx = await adapter.revokeRole(OPERATOR_ROLE, watchdogAddress)
> console.log("Operator role revoked:", tx.hash)
```

**Step 4: Verify Removal**
```bash
# Confirm watchdog is no longer active
> const isActive = await consensus.isActiveWatchdog(watchdogAddress)
> console.log("Watchdog still active:", isActive) // Should be false
```

**✅ Watchdog Removal Complete**

---

## 📋 Operation Checklists

### Pre-Operation Checklist
- [ ] System is not paused
- [ ] Your watchdog is active
- [ ] No pending challenges on similar operations
- [ ] Network conditions are stable
- [ ] Gas prices are reasonable

### Post-Operation Checklist
- [ ] Transaction confirmed
- [ ] Event emitted correctly
- [ ] Operation ID recorded
- [ ] Monitoring updated
- [ ] Documentation updated

### Emergency Checklist
- [ ] Threat assessed and documented
- [ ] Emergency team notified
- [ ] Actions taken are logged
- [ ] Public communication prepared
- [ ] Recovery plan activated

---

**💡 Remember**: Always document your actions and communicate with the team. When in doubt, ask for help!